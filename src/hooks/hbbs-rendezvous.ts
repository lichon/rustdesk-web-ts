/* eslint-disable */
// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "rendezvous.proto" (package "hbb", syntax proto3)
// tslint:disable
import type { PartialMessage, IBinaryReader, IBinaryWriter, BinaryWriteOptions, BinaryReadOptions } from "@protobuf-ts/runtime";
import { WireType, UnknownFieldHandler, reflectionMergePartial, MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message hbb.RegisterPeer
 */
export interface RegisterPeer {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: int32 serial = 2
     */
    serial: number;
}
/**
 * @generated from protobuf message hbb.RegisterPeerResponse
 */
export interface RegisterPeerResponse {
    /**
     * @generated from protobuf field: bool request_pk = 2
     */
    requestPk: boolean;
}
/**
 * @generated from protobuf message hbb.PunchHoleRequest
 */
export interface PunchHoleRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: hbb.NatType nat_type = 2
     */
    natType: NatType;
    /**
     * @generated from protobuf field: string licence_key = 3
     */
    licenceKey: string;
    /**
     * @generated from protobuf field: hbb.ConnType conn_type = 4
     */
    connType: ConnType;
    /**
     * @generated from protobuf field: string token = 5
     */
    token: string;
    /**
     * @generated from protobuf field: string version = 6
     */
    version: string;
    /**
     * @generated from protobuf field: int32 udp_port = 7
     */
    udpPort: number;
    /**
     * @generated from protobuf field: bool force_relay = 8
     */
    forceRelay: boolean;
    /**
     * @generated from protobuf field: int32 upnp_port = 9
     */
    upnpPort: number;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 10
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf message hbb.PunchHole
 */
export interface PunchHole {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: string relay_server = 2
     */
    relayServer: string;
    /**
     * @generated from protobuf field: hbb.NatType nat_type = 3
     */
    natType: NatType;
    /**
     * @generated from protobuf field: int32 udp_port = 4
     */
    udpPort: number;
    /**
     * @generated from protobuf field: bool force_relay = 5
     */
    forceRelay: boolean;
    /**
     * @generated from protobuf field: int32 upnp_port = 6
     */
    upnpPort: number;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 7
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf message hbb.TestNatRequest
 */
export interface TestNatRequest {
    /**
     * @generated from protobuf field: int32 serial = 1
     */
    serial: number;
}
/**
 * per my test, uint/int has no difference in encoding, int not good for negative, use sint for negative
 *
 * @generated from protobuf message hbb.TestNatResponse
 */
export interface TestNatResponse {
    /**
     * @generated from protobuf field: int32 port = 1
     */
    port: number;
    /**
     * @generated from protobuf field: hbb.ConfigUpdate cu = 2
     */
    cu?: ConfigUpdate; // for mobile
}
/**
 * @generated from protobuf message hbb.PunchHoleSent
 */
export interface PunchHoleSent {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: string id = 2
     */
    id: string;
    /**
     * @generated from protobuf field: string relay_server = 3
     */
    relayServer: string;
    /**
     * @generated from protobuf field: hbb.NatType nat_type = 4
     */
    natType: NatType;
    /**
     * @generated from protobuf field: string version = 5
     */
    version: string;
    /**
     * @generated from protobuf field: int32 upnp_port = 6
     */
    upnpPort: number;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 7
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf message hbb.RegisterPk
 */
export interface RegisterPk {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: bytes uuid = 2
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: bytes pk = 3
     */
    pk: Uint8Array;
    /**
     * @generated from protobuf field: string old_id = 4
     */
    oldId: string;
    /**
     * @generated from protobuf field: bool no_register_device = 5
     */
    noRegisterDevice: boolean;
}
/**
 * @generated from protobuf message hbb.RegisterPkResponse
 */
export interface RegisterPkResponse {
    /**
     * @generated from protobuf field: hbb.RegisterPkResponse.Result result = 1
     */
    result: RegisterPkResponse_Result;
    /**
     * @generated from protobuf field: int32 keep_alive = 2
     */
    keepAlive: number;
}
/**
 * @generated from protobuf enum hbb.RegisterPkResponse.Result
 */
export enum RegisterPkResponse_Result {
    /**
     * @generated from protobuf enum value: OK = 0;
     */
    OK = 0,
    /**
     * @generated from protobuf enum value: UUID_MISMATCH = 2;
     */
    UUID_MISMATCH = 2,
    /**
     * @generated from protobuf enum value: ID_EXISTS = 3;
     */
    ID_EXISTS = 3,
    /**
     * @generated from protobuf enum value: TOO_FREQUENT = 4;
     */
    TOO_FREQUENT = 4,
    /**
     * @generated from protobuf enum value: INVALID_ID_FORMAT = 5;
     */
    INVALID_ID_FORMAT = 5,
    /**
     * @generated from protobuf enum value: NOT_SUPPORT = 6;
     */
    NOT_SUPPORT = 6,
    /**
     * @generated from protobuf enum value: SERVER_ERROR = 7;
     */
    SERVER_ERROR = 7
}
/**
 * @generated from protobuf message hbb.PunchHoleResponse
 */
export interface PunchHoleResponse {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: bytes pk = 2
     */
    pk: Uint8Array;
    /**
     * @generated from protobuf field: hbb.PunchHoleResponse.Failure failure = 3
     */
    failure: PunchHoleResponse_Failure;
    /**
     * @generated from protobuf field: string relay_server = 4
     */
    relayServer: string;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "natType";
        /**
         * @generated from protobuf field: hbb.NatType nat_type = 5
         */
        natType: NatType;
    } | {
        oneofKind: "isLocal";
        /**
         * @generated from protobuf field: bool is_local = 6
         */
        isLocal: boolean;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string other_failure = 7
     */
    otherFailure: string;
    /**
     * @generated from protobuf field: int32 feedback = 8
     */
    feedback: number;
    /**
     * @generated from protobuf field: bool is_udp = 9
     */
    isUdp: boolean;
    /**
     * @generated from protobuf field: int32 upnp_port = 10
     */
    upnpPort: number;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 11
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf enum hbb.PunchHoleResponse.Failure
 */
export enum PunchHoleResponse_Failure {
    /**
     * @generated from protobuf enum value: ID_NOT_EXIST = 0;
     */
    ID_NOT_EXIST = 0,
    /**
     * @generated from protobuf enum value: OFFLINE = 2;
     */
    OFFLINE = 2,
    /**
     * @generated from protobuf enum value: LICENSE_MISMATCH = 3;
     */
    LICENSE_MISMATCH = 3,
    /**
     * @generated from protobuf enum value: LICENSE_OVERUSE = 4;
     */
    LICENSE_OVERUSE = 4
}
/**
 * @generated from protobuf message hbb.ConfigUpdate
 */
export interface ConfigUpdate {
    /**
     * @generated from protobuf field: int32 serial = 1
     */
    serial: number;
    /**
     * @generated from protobuf field: repeated string rendezvous_servers = 2
     */
    rendezvousServers: string[];
}
/**
 * @generated from protobuf message hbb.RequestRelay
 */
export interface RequestRelay {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string uuid = 2
     */
    uuid: string;
    /**
     * @generated from protobuf field: bytes socket_addr = 3
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: string relay_server = 4
     */
    relayServer: string;
    /**
     * @generated from protobuf field: bool secure = 5
     */
    secure: boolean;
    /**
     * @generated from protobuf field: string licence_key = 6
     */
    licenceKey: string;
    /**
     * @generated from protobuf field: hbb.ConnType conn_type = 7
     */
    connType: ConnType;
    /**
     * @generated from protobuf field: string token = 8
     */
    token: string;
}
/**
 * @generated from protobuf message hbb.RelayResponse
 */
export interface RelayResponse {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: string uuid = 2
     */
    uuid: string;
    /**
     * @generated from protobuf field: string relay_server = 3
     */
    relayServer: string;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "id";
        /**
         * @generated from protobuf field: string id = 4
         */
        id: string;
    } | {
        oneofKind: "pk";
        /**
         * @generated from protobuf field: bytes pk = 5
         */
        pk: Uint8Array;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: string refuse_reason = 6
     */
    refuseReason: string;
    /**
     * @generated from protobuf field: string version = 7
     */
    version: string;
    /**
     * @generated from protobuf field: int32 feedback = 9
     */
    feedback: number;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 10
     */
    socketAddrV6: Uint8Array;
    /**
     * @generated from protobuf field: int32 upnp_port = 11
     */
    upnpPort: number;
}
/**
 * @generated from protobuf message hbb.SoftwareUpdate
 */
export interface SoftwareUpdate {
    /**
     * @generated from protobuf field: string url = 1
     */
    url: string;
}
/**
 * if in same intranet, punch hole won't work both for udp and tcp,
 * even some router has below connection error if we connect itself,
 *  { kind: Other, error: "could not resolve to any address" },
 * so we request local address to connect.
 *
 * @generated from protobuf message hbb.FetchLocalAddr
 */
export interface FetchLocalAddr {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: string relay_server = 2
     */
    relayServer: string;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 3
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf message hbb.LocalAddr
 */
export interface LocalAddr {
    /**
     * @generated from protobuf field: bytes socket_addr = 1
     */
    socketAddr: Uint8Array;
    /**
     * @generated from protobuf field: bytes local_addr = 2
     */
    localAddr: Uint8Array;
    /**
     * @generated from protobuf field: string relay_server = 3
     */
    relayServer: string;
    /**
     * @generated from protobuf field: string id = 4
     */
    id: string;
    /**
     * @generated from protobuf field: string version = 5
     */
    version: string;
    /**
     * @generated from protobuf field: bytes socket_addr_v6 = 6
     */
    socketAddrV6: Uint8Array;
}
/**
 * @generated from protobuf message hbb.PeerDiscovery
 */
export interface PeerDiscovery {
    /**
     * @generated from protobuf field: string cmd = 1
     */
    cmd: string;
    /**
     * @generated from protobuf field: string mac = 2
     */
    mac: string;
    /**
     * @generated from protobuf field: string id = 3
     */
    id: string;
    /**
     * @generated from protobuf field: string username = 4
     */
    username: string;
    /**
     * @generated from protobuf field: string hostname = 5
     */
    hostname: string;
    /**
     * @generated from protobuf field: string platform = 6
     */
    platform: string;
    /**
     * @generated from protobuf field: string misc = 7
     */
    misc: string;
}
/**
 * @generated from protobuf message hbb.OnlineRequest
 */
export interface OnlineRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: repeated string peers = 2
     */
    peers: string[];
}
/**
 * @generated from protobuf message hbb.OnlineResponse
 */
export interface OnlineResponse {
    /**
     * @generated from protobuf field: bytes states = 1
     */
    states: Uint8Array;
}
/**
 * @generated from protobuf message hbb.KeyExchange
 */
export interface KeyExchange {
    /**
     * @generated from protobuf field: repeated bytes keys = 1
     */
    keys: Uint8Array[];
}
/**
 * @generated from protobuf message hbb.HealthCheck
 */
export interface HealthCheck {
    /**
     * @generated from protobuf field: string token = 1
     */
    token: string;
}
/**
 * @generated from protobuf message hbb.RendezvousMessage
 */
export interface RendezvousMessage {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "registerPeer";
        /**
         * @generated from protobuf field: hbb.RegisterPeer register_peer = 6
         */
        registerPeer: RegisterPeer;
    } | {
        oneofKind: "registerPeerResponse";
        /**
         * @generated from protobuf field: hbb.RegisterPeerResponse register_peer_response = 7
         */
        registerPeerResponse: RegisterPeerResponse;
    } | {
        oneofKind: "punchHoleRequest";
        /**
         * @generated from protobuf field: hbb.PunchHoleRequest punch_hole_request = 8
         */
        punchHoleRequest: PunchHoleRequest;
    } | {
        oneofKind: "punchHole";
        /**
         * @generated from protobuf field: hbb.PunchHole punch_hole = 9
         */
        punchHole: PunchHole;
    } | {
        oneofKind: "punchHoleSent";
        /**
         * @generated from protobuf field: hbb.PunchHoleSent punch_hole_sent = 10
         */
        punchHoleSent: PunchHoleSent;
    } | {
        oneofKind: "punchHoleResponse";
        /**
         * @generated from protobuf field: hbb.PunchHoleResponse punch_hole_response = 11
         */
        punchHoleResponse: PunchHoleResponse;
    } | {
        oneofKind: "fetchLocalAddr";
        /**
         * @generated from protobuf field: hbb.FetchLocalAddr fetch_local_addr = 12
         */
        fetchLocalAddr: FetchLocalAddr;
    } | {
        oneofKind: "localAddr";
        /**
         * @generated from protobuf field: hbb.LocalAddr local_addr = 13
         */
        localAddr: LocalAddr;
    } | {
        oneofKind: "configureUpdate";
        /**
         * @generated from protobuf field: hbb.ConfigUpdate configure_update = 14
         */
        configureUpdate: ConfigUpdate;
    } | {
        oneofKind: "registerPk";
        /**
         * @generated from protobuf field: hbb.RegisterPk register_pk = 15
         */
        registerPk: RegisterPk;
    } | {
        oneofKind: "registerPkResponse";
        /**
         * @generated from protobuf field: hbb.RegisterPkResponse register_pk_response = 16
         */
        registerPkResponse: RegisterPkResponse;
    } | {
        oneofKind: "softwareUpdate";
        /**
         * @generated from protobuf field: hbb.SoftwareUpdate software_update = 17
         */
        softwareUpdate: SoftwareUpdate;
    } | {
        oneofKind: "requestRelay";
        /**
         * @generated from protobuf field: hbb.RequestRelay request_relay = 18
         */
        requestRelay: RequestRelay;
    } | {
        oneofKind: "relayResponse";
        /**
         * @generated from protobuf field: hbb.RelayResponse relay_response = 19
         */
        relayResponse: RelayResponse;
    } | {
        oneofKind: "testNatRequest";
        /**
         * @generated from protobuf field: hbb.TestNatRequest test_nat_request = 20
         */
        testNatRequest: TestNatRequest;
    } | {
        oneofKind: "testNatResponse";
        /**
         * @generated from protobuf field: hbb.TestNatResponse test_nat_response = 21
         */
        testNatResponse: TestNatResponse;
    } | {
        oneofKind: "peerDiscovery";
        /**
         * @generated from protobuf field: hbb.PeerDiscovery peer_discovery = 22
         */
        peerDiscovery: PeerDiscovery;
    } | {
        oneofKind: "onlineRequest";
        /**
         * @generated from protobuf field: hbb.OnlineRequest online_request = 23
         */
        onlineRequest: OnlineRequest;
    } | {
        oneofKind: "onlineResponse";
        /**
         * @generated from protobuf field: hbb.OnlineResponse online_response = 24
         */
        onlineResponse: OnlineResponse;
    } | {
        oneofKind: "keyExchange";
        /**
         * @generated from protobuf field: hbb.KeyExchange key_exchange = 25
         */
        keyExchange: KeyExchange;
    } | {
        oneofKind: "hc";
        /**
         * @generated from protobuf field: hbb.HealthCheck hc = 26
         */
        hc: HealthCheck;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum hbb.ConnType
 */
export enum ConnType {
    /**
     * @generated from protobuf enum value: DEFAULT_CONN = 0;
     */
    DEFAULT_CONN = 0,
    /**
     * @generated from protobuf enum value: FILE_TRANSFER = 1;
     */
    FILE_TRANSFER = 1,
    /**
     * @generated from protobuf enum value: PORT_FORWARD = 2;
     */
    PORT_FORWARD = 2,
    /**
     * @generated from protobuf enum value: RDP = 3;
     */
    RDP = 3,
    /**
     * @generated from protobuf enum value: VIEW_CAMERA = 4;
     */
    VIEW_CAMERA = 4,
    /**
     * @generated from protobuf enum value: TERMINAL = 5;
     */
    TERMINAL = 5
}
/**
 * @generated from protobuf enum hbb.NatType
 */
export enum NatType {
    /**
     * @generated from protobuf enum value: UNKNOWN_NAT = 0;
     */
    UNKNOWN_NAT = 0,
    /**
     * @generated from protobuf enum value: ASYMMETRIC = 1;
     */
    ASYMMETRIC = 1,
    /**
     * @generated from protobuf enum value: SYMMETRIC = 2;
     */
    SYMMETRIC = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class RegisterPeer$Type extends MessageType<RegisterPeer> {
    constructor() {
        super("hbb.RegisterPeer", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "serial", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterPeer>): RegisterPeer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.serial = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterPeer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterPeer): RegisterPeer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* int32 serial */ 2:
                    message.serial = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterPeer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* int32 serial = 2; */
        if (message.serial !== 0)
            writer.tag(2, WireType.Varint).int32(message.serial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RegisterPeer
 */
export const RegisterPeer = new RegisterPeer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterPeerResponse$Type extends MessageType<RegisterPeerResponse> {
    constructor() {
        super("hbb.RegisterPeerResponse", [
            { no: 2, name: "request_pk", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterPeerResponse>): RegisterPeerResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestPk = false;
        if (value !== undefined)
            reflectionMergePartial<RegisterPeerResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterPeerResponse): RegisterPeerResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool request_pk */ 2:
                    message.requestPk = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterPeerResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool request_pk = 2; */
        if (message.requestPk !== false)
            writer.tag(2, WireType.Varint).bool(message.requestPk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RegisterPeerResponse
 */
export const RegisterPeerResponse = new RegisterPeerResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PunchHoleRequest$Type extends MessageType<PunchHoleRequest> {
    constructor() {
        super("hbb.PunchHoleRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nat_type", kind: "enum", T: () => ["hbb.NatType", NatType] },
            { no: 3, name: "licence_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "conn_type", kind: "enum", T: () => ["hbb.ConnType", ConnType] },
            { no: 5, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "udp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "force_relay", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "upnp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PunchHoleRequest>): PunchHoleRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.natType = 0;
        message.licenceKey = "";
        message.connType = 0;
        message.token = "";
        message.version = "";
        message.udpPort = 0;
        message.forceRelay = false;
        message.upnpPort = 0;
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PunchHoleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PunchHoleRequest): PunchHoleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* hbb.NatType nat_type */ 2:
                    message.natType = reader.int32();
                    break;
                case /* string licence_key */ 3:
                    message.licenceKey = reader.string();
                    break;
                case /* hbb.ConnType conn_type */ 4:
                    message.connType = reader.int32();
                    break;
                case /* string token */ 5:
                    message.token = reader.string();
                    break;
                case /* string version */ 6:
                    message.version = reader.string();
                    break;
                case /* int32 udp_port */ 7:
                    message.udpPort = reader.int32();
                    break;
                case /* bool force_relay */ 8:
                    message.forceRelay = reader.bool();
                    break;
                case /* int32 upnp_port */ 9:
                    message.upnpPort = reader.int32();
                    break;
                case /* bytes socket_addr_v6 */ 10:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PunchHoleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* hbb.NatType nat_type = 2; */
        if (message.natType !== 0)
            writer.tag(2, WireType.Varint).int32(message.natType);
        /* string licence_key = 3; */
        if (message.licenceKey !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.licenceKey);
        /* hbb.ConnType conn_type = 4; */
        if (message.connType !== 0)
            writer.tag(4, WireType.Varint).int32(message.connType);
        /* string token = 5; */
        if (message.token !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.token);
        /* string version = 6; */
        if (message.version !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.version);
        /* int32 udp_port = 7; */
        if (message.udpPort !== 0)
            writer.tag(7, WireType.Varint).int32(message.udpPort);
        /* bool force_relay = 8; */
        if (message.forceRelay !== false)
            writer.tag(8, WireType.Varint).bool(message.forceRelay);
        /* int32 upnp_port = 9; */
        if (message.upnpPort !== 0)
            writer.tag(9, WireType.Varint).int32(message.upnpPort);
        /* bytes socket_addr_v6 = 10; */
        if (message.socketAddrV6.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PunchHoleRequest
 */
export const PunchHoleRequest = new PunchHoleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PunchHole$Type extends MessageType<PunchHole> {
    constructor() {
        super("hbb.PunchHole", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nat_type", kind: "enum", T: () => ["hbb.NatType", NatType] },
            { no: 4, name: "udp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "force_relay", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "upnp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PunchHole>): PunchHole {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.relayServer = "";
        message.natType = 0;
        message.udpPort = 0;
        message.forceRelay = false;
        message.upnpPort = 0;
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PunchHole>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PunchHole): PunchHole {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* string relay_server */ 2:
                    message.relayServer = reader.string();
                    break;
                case /* hbb.NatType nat_type */ 3:
                    message.natType = reader.int32();
                    break;
                case /* int32 udp_port */ 4:
                    message.udpPort = reader.int32();
                    break;
                case /* bool force_relay */ 5:
                    message.forceRelay = reader.bool();
                    break;
                case /* int32 upnp_port */ 6:
                    message.upnpPort = reader.int32();
                    break;
                case /* bytes socket_addr_v6 */ 7:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PunchHole, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* string relay_server = 2; */
        if (message.relayServer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relayServer);
        /* hbb.NatType nat_type = 3; */
        if (message.natType !== 0)
            writer.tag(3, WireType.Varint).int32(message.natType);
        /* int32 udp_port = 4; */
        if (message.udpPort !== 0)
            writer.tag(4, WireType.Varint).int32(message.udpPort);
        /* bool force_relay = 5; */
        if (message.forceRelay !== false)
            writer.tag(5, WireType.Varint).bool(message.forceRelay);
        /* int32 upnp_port = 6; */
        if (message.upnpPort !== 0)
            writer.tag(6, WireType.Varint).int32(message.upnpPort);
        /* bytes socket_addr_v6 = 7; */
        if (message.socketAddrV6.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PunchHole
 */
export const PunchHole = new PunchHole$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNatRequest$Type extends MessageType<TestNatRequest> {
    constructor() {
        super("hbb.TestNatRequest", [
            { no: 1, name: "serial", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestNatRequest>): TestNatRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serial = 0;
        if (value !== undefined)
            reflectionMergePartial<TestNatRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNatRequest): TestNatRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 serial */ 1:
                    message.serial = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNatRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 serial = 1; */
        if (message.serial !== 0)
            writer.tag(1, WireType.Varint).int32(message.serial);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TestNatRequest
 */
export const TestNatRequest = new TestNatRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestNatResponse$Type extends MessageType<TestNatResponse> {
    constructor() {
        super("hbb.TestNatResponse", [
            { no: 1, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cu", kind: "message", T: () => ConfigUpdate }
        ]);
    }
    create(value?: PartialMessage<TestNatResponse>): TestNatResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<TestNatResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestNatResponse): TestNatResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 port */ 1:
                    message.port = reader.int32();
                    break;
                case /* hbb.ConfigUpdate cu */ 2:
                    message.cu = ConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, message.cu);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestNatResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 port = 1; */
        if (message.port !== 0)
            writer.tag(1, WireType.Varint).int32(message.port);
        /* hbb.ConfigUpdate cu = 2; */
        if (message.cu)
            ConfigUpdate.internalBinaryWrite(message.cu, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TestNatResponse
 */
export const TestNatResponse = new TestNatResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PunchHoleSent$Type extends MessageType<PunchHoleSent> {
    constructor() {
        super("hbb.PunchHoleSent", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "nat_type", kind: "enum", T: () => ["hbb.NatType", NatType] },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "upnp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PunchHoleSent>): PunchHoleSent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.id = "";
        message.relayServer = "";
        message.natType = 0;
        message.version = "";
        message.upnpPort = 0;
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PunchHoleSent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PunchHoleSent): PunchHoleSent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* string id */ 2:
                    message.id = reader.string();
                    break;
                case /* string relay_server */ 3:
                    message.relayServer = reader.string();
                    break;
                case /* hbb.NatType nat_type */ 4:
                    message.natType = reader.int32();
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* int32 upnp_port */ 6:
                    message.upnpPort = reader.int32();
                    break;
                case /* bytes socket_addr_v6 */ 7:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PunchHoleSent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* string id = 2; */
        if (message.id !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.id);
        /* string relay_server = 3; */
        if (message.relayServer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relayServer);
        /* hbb.NatType nat_type = 4; */
        if (message.natType !== 0)
            writer.tag(4, WireType.Varint).int32(message.natType);
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* int32 upnp_port = 6; */
        if (message.upnpPort !== 0)
            writer.tag(6, WireType.Varint).int32(message.upnpPort);
        /* bytes socket_addr_v6 = 7; */
        if (message.socketAddrV6.length)
            writer.tag(7, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PunchHoleSent
 */
export const PunchHoleSent = new PunchHoleSent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterPk$Type extends MessageType<RegisterPk> {
    constructor() {
        super("hbb.RegisterPk", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "pk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "old_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "no_register_device", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterPk>): RegisterPk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.uuid = new Uint8Array(0);
        message.pk = new Uint8Array(0);
        message.oldId = "";
        message.noRegisterDevice = false;
        if (value !== undefined)
            reflectionMergePartial<RegisterPk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterPk): RegisterPk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes uuid */ 2:
                    message.uuid = reader.bytes();
                    break;
                case /* bytes pk */ 3:
                    message.pk = reader.bytes();
                    break;
                case /* string old_id */ 4:
                    message.oldId = reader.string();
                    break;
                case /* bool no_register_device */ 5:
                    message.noRegisterDevice = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterPk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes uuid = 2; */
        if (message.uuid.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.uuid);
        /* bytes pk = 3; */
        if (message.pk.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.pk);
        /* string old_id = 4; */
        if (message.oldId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.oldId);
        /* bool no_register_device = 5; */
        if (message.noRegisterDevice !== false)
            writer.tag(5, WireType.Varint).bool(message.noRegisterDevice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RegisterPk
 */
export const RegisterPk = new RegisterPk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RegisterPkResponse$Type extends MessageType<RegisterPkResponse> {
    constructor() {
        super("hbb.RegisterPkResponse", [
            { no: 1, name: "result", kind: "enum", T: () => ["hbb.RegisterPkResponse.Result", RegisterPkResponse_Result] },
            { no: 2, name: "keep_alive", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RegisterPkResponse>): RegisterPkResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.result = 0;
        message.keepAlive = 0;
        if (value !== undefined)
            reflectionMergePartial<RegisterPkResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RegisterPkResponse): RegisterPkResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.RegisterPkResponse.Result result */ 1:
                    message.result = reader.int32();
                    break;
                case /* int32 keep_alive */ 2:
                    message.keepAlive = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RegisterPkResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.RegisterPkResponse.Result result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* int32 keep_alive = 2; */
        if (message.keepAlive !== 0)
            writer.tag(2, WireType.Varint).int32(message.keepAlive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RegisterPkResponse
 */
export const RegisterPkResponse = new RegisterPkResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PunchHoleResponse$Type extends MessageType<PunchHoleResponse> {
    constructor() {
        super("hbb.PunchHoleResponse", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "pk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "failure", kind: "enum", T: () => ["hbb.PunchHoleResponse.Failure", PunchHoleResponse_Failure] },
            { no: 4, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "nat_type", kind: "enum", oneof: "union", T: () => ["hbb.NatType", NatType] },
            { no: 6, name: "is_local", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "other_failure", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "feedback", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "is_udp", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "upnp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PunchHoleResponse>): PunchHoleResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.pk = new Uint8Array(0);
        message.failure = 0;
        message.relayServer = "";
        message.union = { oneofKind: undefined };
        message.otherFailure = "";
        message.feedback = 0;
        message.isUdp = false;
        message.upnpPort = 0;
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PunchHoleResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PunchHoleResponse): PunchHoleResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* bytes pk */ 2:
                    message.pk = reader.bytes();
                    break;
                case /* hbb.PunchHoleResponse.Failure failure */ 3:
                    message.failure = reader.int32();
                    break;
                case /* string relay_server */ 4:
                    message.relayServer = reader.string();
                    break;
                case /* hbb.NatType nat_type */ 5:
                    message.union = {
                        oneofKind: "natType",
                        natType: reader.int32()
                    };
                    break;
                case /* bool is_local */ 6:
                    message.union = {
                        oneofKind: "isLocal",
                        isLocal: reader.bool()
                    };
                    break;
                case /* string other_failure */ 7:
                    message.otherFailure = reader.string();
                    break;
                case /* int32 feedback */ 8:
                    message.feedback = reader.int32();
                    break;
                case /* bool is_udp */ 9:
                    message.isUdp = reader.bool();
                    break;
                case /* int32 upnp_port */ 10:
                    message.upnpPort = reader.int32();
                    break;
                case /* bytes socket_addr_v6 */ 11:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PunchHoleResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* bytes pk = 2; */
        if (message.pk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pk);
        /* hbb.PunchHoleResponse.Failure failure = 3; */
        if (message.failure !== 0)
            writer.tag(3, WireType.Varint).int32(message.failure);
        /* string relay_server = 4; */
        if (message.relayServer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.relayServer);
        /* hbb.NatType nat_type = 5; */
        if (message.union.oneofKind === "natType")
            writer.tag(5, WireType.Varint).int32(message.union.natType);
        /* bool is_local = 6; */
        if (message.union.oneofKind === "isLocal")
            writer.tag(6, WireType.Varint).bool(message.union.isLocal);
        /* string other_failure = 7; */
        if (message.otherFailure !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.otherFailure);
        /* int32 feedback = 8; */
        if (message.feedback !== 0)
            writer.tag(8, WireType.Varint).int32(message.feedback);
        /* bool is_udp = 9; */
        if (message.isUdp !== false)
            writer.tag(9, WireType.Varint).bool(message.isUdp);
        /* int32 upnp_port = 10; */
        if (message.upnpPort !== 0)
            writer.tag(10, WireType.Varint).int32(message.upnpPort);
        /* bytes socket_addr_v6 = 11; */
        if (message.socketAddrV6.length)
            writer.tag(11, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PunchHoleResponse
 */
export const PunchHoleResponse = new PunchHoleResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigUpdate$Type extends MessageType<ConfigUpdate> {
    constructor() {
        super("hbb.ConfigUpdate", [
            { no: 1, name: "serial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rendezvous_servers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ConfigUpdate>): ConfigUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serial = 0;
        message.rendezvousServers = [];
        if (value !== undefined)
            reflectionMergePartial<ConfigUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigUpdate): ConfigUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 serial */ 1:
                    message.serial = reader.int32();
                    break;
                case /* repeated string rendezvous_servers */ 2:
                    message.rendezvousServers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 serial = 1; */
        if (message.serial !== 0)
            writer.tag(1, WireType.Varint).int32(message.serial);
        /* repeated string rendezvous_servers = 2; */
        for (let i = 0; i < message.rendezvousServers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.rendezvousServers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ConfigUpdate
 */
export const ConfigUpdate = new ConfigUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RequestRelay$Type extends MessageType<RequestRelay> {
    constructor() {
        super("hbb.RequestRelay", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "secure", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "licence_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "conn_type", kind: "enum", T: () => ["hbb.ConnType", ConnType] },
            { no: 8, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RequestRelay>): RequestRelay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.uuid = "";
        message.socketAddr = new Uint8Array(0);
        message.relayServer = "";
        message.secure = false;
        message.licenceKey = "";
        message.connType = 0;
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<RequestRelay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RequestRelay): RequestRelay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* bytes socket_addr */ 3:
                    message.socketAddr = reader.bytes();
                    break;
                case /* string relay_server */ 4:
                    message.relayServer = reader.string();
                    break;
                case /* bool secure */ 5:
                    message.secure = reader.bool();
                    break;
                case /* string licence_key */ 6:
                    message.licenceKey = reader.string();
                    break;
                case /* hbb.ConnType conn_type */ 7:
                    message.connType = reader.int32();
                    break;
                case /* string token */ 8:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RequestRelay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* bytes socket_addr = 3; */
        if (message.socketAddr.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.socketAddr);
        /* string relay_server = 4; */
        if (message.relayServer !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.relayServer);
        /* bool secure = 5; */
        if (message.secure !== false)
            writer.tag(5, WireType.Varint).bool(message.secure);
        /* string licence_key = 6; */
        if (message.licenceKey !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.licenceKey);
        /* hbb.ConnType conn_type = 7; */
        if (message.connType !== 0)
            writer.tag(7, WireType.Varint).int32(message.connType);
        /* string token = 8; */
        if (message.token !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RequestRelay
 */
export const RequestRelay = new RequestRelay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelayResponse$Type extends MessageType<RelayResponse> {
    constructor() {
        super("hbb.RelayResponse", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "id", kind: "scalar", oneof: "union", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "pk", kind: "scalar", oneof: "union", T: 12 /*ScalarType.BYTES*/ },
            { no: 6, name: "refuse_reason", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "feedback", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 11, name: "upnp_port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RelayResponse>): RelayResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.uuid = "";
        message.relayServer = "";
        message.union = { oneofKind: undefined };
        message.refuseReason = "";
        message.version = "";
        message.feedback = 0;
        message.socketAddrV6 = new Uint8Array(0);
        message.upnpPort = 0;
        if (value !== undefined)
            reflectionMergePartial<RelayResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelayResponse): RelayResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* string uuid */ 2:
                    message.uuid = reader.string();
                    break;
                case /* string relay_server */ 3:
                    message.relayServer = reader.string();
                    break;
                case /* string id */ 4:
                    message.union = {
                        oneofKind: "id",
                        id: reader.string()
                    };
                    break;
                case /* bytes pk */ 5:
                    message.union = {
                        oneofKind: "pk",
                        pk: reader.bytes()
                    };
                    break;
                case /* string refuse_reason */ 6:
                    message.refuseReason = reader.string();
                    break;
                case /* string version */ 7:
                    message.version = reader.string();
                    break;
                case /* int32 feedback */ 9:
                    message.feedback = reader.int32();
                    break;
                case /* bytes socket_addr_v6 */ 10:
                    message.socketAddrV6 = reader.bytes();
                    break;
                case /* int32 upnp_port */ 11:
                    message.upnpPort = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelayResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* string uuid = 2; */
        if (message.uuid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uuid);
        /* string relay_server = 3; */
        if (message.relayServer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relayServer);
        /* string id = 4; */
        if (message.union.oneofKind === "id")
            writer.tag(4, WireType.LengthDelimited).string(message.union.id);
        /* bytes pk = 5; */
        if (message.union.oneofKind === "pk")
            writer.tag(5, WireType.LengthDelimited).bytes(message.union.pk);
        /* string refuse_reason = 6; */
        if (message.refuseReason !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.refuseReason);
        /* string version = 7; */
        if (message.version !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.version);
        /* int32 feedback = 9; */
        if (message.feedback !== 0)
            writer.tag(9, WireType.Varint).int32(message.feedback);
        /* bytes socket_addr_v6 = 10; */
        if (message.socketAddrV6.length)
            writer.tag(10, WireType.LengthDelimited).bytes(message.socketAddrV6);
        /* int32 upnp_port = 11; */
        if (message.upnpPort !== 0)
            writer.tag(11, WireType.Varint).int32(message.upnpPort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RelayResponse
 */
export const RelayResponse = new RelayResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SoftwareUpdate$Type extends MessageType<SoftwareUpdate> {
    constructor() {
        super("hbb.SoftwareUpdate", [
            { no: 1, name: "url", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SoftwareUpdate>): SoftwareUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.url = "";
        if (value !== undefined)
            reflectionMergePartial<SoftwareUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SoftwareUpdate): SoftwareUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string url */ 1:
                    message.url = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SoftwareUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string url = 1; */
        if (message.url !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.url);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SoftwareUpdate
 */
export const SoftwareUpdate = new SoftwareUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchLocalAddr$Type extends MessageType<FetchLocalAddr> {
    constructor() {
        super("hbb.FetchLocalAddr", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<FetchLocalAddr>): FetchLocalAddr {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.relayServer = "";
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<FetchLocalAddr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchLocalAddr): FetchLocalAddr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* string relay_server */ 2:
                    message.relayServer = reader.string();
                    break;
                case /* bytes socket_addr_v6 */ 3:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchLocalAddr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* string relay_server = 2; */
        if (message.relayServer !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.relayServer);
        /* bytes socket_addr_v6 = 3; */
        if (message.socketAddrV6.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FetchLocalAddr
 */
export const FetchLocalAddr = new FetchLocalAddr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LocalAddr$Type extends MessageType<LocalAddr> {
    constructor() {
        super("hbb.LocalAddr", [
            { no: 1, name: "socket_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "local_addr", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "relay_server", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "socket_addr_v6", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LocalAddr>): LocalAddr {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.socketAddr = new Uint8Array(0);
        message.localAddr = new Uint8Array(0);
        message.relayServer = "";
        message.id = "";
        message.version = "";
        message.socketAddrV6 = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LocalAddr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LocalAddr): LocalAddr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes socket_addr */ 1:
                    message.socketAddr = reader.bytes();
                    break;
                case /* bytes local_addr */ 2:
                    message.localAddr = reader.bytes();
                    break;
                case /* string relay_server */ 3:
                    message.relayServer = reader.string();
                    break;
                case /* string id */ 4:
                    message.id = reader.string();
                    break;
                case /* string version */ 5:
                    message.version = reader.string();
                    break;
                case /* bytes socket_addr_v6 */ 6:
                    message.socketAddrV6 = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LocalAddr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes socket_addr = 1; */
        if (message.socketAddr.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.socketAddr);
        /* bytes local_addr = 2; */
        if (message.localAddr.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.localAddr);
        /* string relay_server = 3; */
        if (message.relayServer !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.relayServer);
        /* string id = 4; */
        if (message.id !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.id);
        /* string version = 5; */
        if (message.version !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.version);
        /* bytes socket_addr_v6 = 6; */
        if (message.socketAddrV6.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.socketAddrV6);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.LocalAddr
 */
export const LocalAddr = new LocalAddr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerDiscovery$Type extends MessageType<PeerDiscovery> {
    constructor() {
        super("hbb.PeerDiscovery", [
            { no: 1, name: "cmd", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mac", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "misc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PeerDiscovery>): PeerDiscovery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cmd = "";
        message.mac = "";
        message.id = "";
        message.username = "";
        message.hostname = "";
        message.platform = "";
        message.misc = "";
        if (value !== undefined)
            reflectionMergePartial<PeerDiscovery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerDiscovery): PeerDiscovery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cmd */ 1:
                    message.cmd = reader.string();
                    break;
                case /* string mac */ 2:
                    message.mac = reader.string();
                    break;
                case /* string id */ 3:
                    message.id = reader.string();
                    break;
                case /* string username */ 4:
                    message.username = reader.string();
                    break;
                case /* string hostname */ 5:
                    message.hostname = reader.string();
                    break;
                case /* string platform */ 6:
                    message.platform = reader.string();
                    break;
                case /* string misc */ 7:
                    message.misc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeerDiscovery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cmd = 1; */
        if (message.cmd !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cmd);
        /* string mac = 2; */
        if (message.mac !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.mac);
        /* string id = 3; */
        if (message.id !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.id);
        /* string username = 4; */
        if (message.username !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.username);
        /* string hostname = 5; */
        if (message.hostname !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.hostname);
        /* string platform = 6; */
        if (message.platform !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.platform);
        /* string misc = 7; */
        if (message.misc !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.misc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PeerDiscovery
 */
export const PeerDiscovery = new PeerDiscovery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnlineRequest$Type extends MessageType<OnlineRequest> {
    constructor() {
        super("hbb.OnlineRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peers", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OnlineRequest>): OnlineRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.peers = [];
        if (value !== undefined)
            reflectionMergePartial<OnlineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnlineRequest): OnlineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* repeated string peers */ 2:
                    message.peers.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnlineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* repeated string peers = 2; */
        for (let i = 0; i < message.peers.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.peers[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.OnlineRequest
 */
export const OnlineRequest = new OnlineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OnlineResponse$Type extends MessageType<OnlineResponse> {
    constructor() {
        super("hbb.OnlineResponse", [
            { no: 1, name: "states", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<OnlineResponse>): OnlineResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.states = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<OnlineResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OnlineResponse): OnlineResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes states */ 1:
                    message.states = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OnlineResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes states = 1; */
        if (message.states.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.states);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.OnlineResponse
 */
export const OnlineResponse = new OnlineResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyExchange$Type extends MessageType<KeyExchange> {
    constructor() {
        super("hbb.KeyExchange", [
            { no: 1, name: "keys", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<KeyExchange>): KeyExchange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.keys = [];
        if (value !== undefined)
            reflectionMergePartial<KeyExchange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyExchange): KeyExchange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes keys */ 1:
                    message.keys.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyExchange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes keys = 1; */
        for (let i = 0; i < message.keys.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.keys[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.KeyExchange
 */
export const KeyExchange = new KeyExchange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheck$Type extends MessageType<HealthCheck> {
    constructor() {
        super("hbb.HealthCheck", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheck>): HealthCheck {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        if (value !== undefined)
            reflectionMergePartial<HealthCheck>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheck): HealthCheck {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheck, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.HealthCheck
 */
export const HealthCheck = new HealthCheck$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RendezvousMessage$Type extends MessageType<RendezvousMessage> {
    constructor() {
        super("hbb.RendezvousMessage", [
            { no: 6, name: "register_peer", kind: "message", oneof: "union", T: () => RegisterPeer },
            { no: 7, name: "register_peer_response", kind: "message", oneof: "union", T: () => RegisterPeerResponse },
            { no: 8, name: "punch_hole_request", kind: "message", oneof: "union", T: () => PunchHoleRequest },
            { no: 9, name: "punch_hole", kind: "message", oneof: "union", T: () => PunchHole },
            { no: 10, name: "punch_hole_sent", kind: "message", oneof: "union", T: () => PunchHoleSent },
            { no: 11, name: "punch_hole_response", kind: "message", oneof: "union", T: () => PunchHoleResponse },
            { no: 12, name: "fetch_local_addr", kind: "message", oneof: "union", T: () => FetchLocalAddr },
            { no: 13, name: "local_addr", kind: "message", oneof: "union", T: () => LocalAddr },
            { no: 14, name: "configure_update", kind: "message", oneof: "union", T: () => ConfigUpdate },
            { no: 15, name: "register_pk", kind: "message", oneof: "union", T: () => RegisterPk },
            { no: 16, name: "register_pk_response", kind: "message", oneof: "union", T: () => RegisterPkResponse },
            { no: 17, name: "software_update", kind: "message", oneof: "union", T: () => SoftwareUpdate },
            { no: 18, name: "request_relay", kind: "message", oneof: "union", T: () => RequestRelay },
            { no: 19, name: "relay_response", kind: "message", oneof: "union", T: () => RelayResponse },
            { no: 20, name: "test_nat_request", kind: "message", oneof: "union", T: () => TestNatRequest },
            { no: 21, name: "test_nat_response", kind: "message", oneof: "union", T: () => TestNatResponse },
            { no: 22, name: "peer_discovery", kind: "message", oneof: "union", T: () => PeerDiscovery },
            { no: 23, name: "online_request", kind: "message", oneof: "union", T: () => OnlineRequest },
            { no: 24, name: "online_response", kind: "message", oneof: "union", T: () => OnlineResponse },
            { no: 25, name: "key_exchange", kind: "message", oneof: "union", T: () => KeyExchange },
            { no: 26, name: "hc", kind: "message", oneof: "union", T: () => HealthCheck }
        ]);
    }
    create(value?: PartialMessage<RendezvousMessage>): RendezvousMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<RendezvousMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RendezvousMessage): RendezvousMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.RegisterPeer register_peer */ 6:
                    message.union = {
                        oneofKind: "registerPeer",
                        registerPeer: RegisterPeer.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).registerPeer)
                    };
                    break;
                case /* hbb.RegisterPeerResponse register_peer_response */ 7:
                    message.union = {
                        oneofKind: "registerPeerResponse",
                        registerPeerResponse: RegisterPeerResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).registerPeerResponse)
                    };
                    break;
                case /* hbb.PunchHoleRequest punch_hole_request */ 8:
                    message.union = {
                        oneofKind: "punchHoleRequest",
                        punchHoleRequest: PunchHoleRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).punchHoleRequest)
                    };
                    break;
                case /* hbb.PunchHole punch_hole */ 9:
                    message.union = {
                        oneofKind: "punchHole",
                        punchHole: PunchHole.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).punchHole)
                    };
                    break;
                case /* hbb.PunchHoleSent punch_hole_sent */ 10:
                    message.union = {
                        oneofKind: "punchHoleSent",
                        punchHoleSent: PunchHoleSent.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).punchHoleSent)
                    };
                    break;
                case /* hbb.PunchHoleResponse punch_hole_response */ 11:
                    message.union = {
                        oneofKind: "punchHoleResponse",
                        punchHoleResponse: PunchHoleResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).punchHoleResponse)
                    };
                    break;
                case /* hbb.FetchLocalAddr fetch_local_addr */ 12:
                    message.union = {
                        oneofKind: "fetchLocalAddr",
                        fetchLocalAddr: FetchLocalAddr.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fetchLocalAddr)
                    };
                    break;
                case /* hbb.LocalAddr local_addr */ 13:
                    message.union = {
                        oneofKind: "localAddr",
                        localAddr: LocalAddr.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).localAddr)
                    };
                    break;
                case /* hbb.ConfigUpdate configure_update */ 14:
                    message.union = {
                        oneofKind: "configureUpdate",
                        configureUpdate: ConfigUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).configureUpdate)
                    };
                    break;
                case /* hbb.RegisterPk register_pk */ 15:
                    message.union = {
                        oneofKind: "registerPk",
                        registerPk: RegisterPk.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).registerPk)
                    };
                    break;
                case /* hbb.RegisterPkResponse register_pk_response */ 16:
                    message.union = {
                        oneofKind: "registerPkResponse",
                        registerPkResponse: RegisterPkResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).registerPkResponse)
                    };
                    break;
                case /* hbb.SoftwareUpdate software_update */ 17:
                    message.union = {
                        oneofKind: "softwareUpdate",
                        softwareUpdate: SoftwareUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).softwareUpdate)
                    };
                    break;
                case /* hbb.RequestRelay request_relay */ 18:
                    message.union = {
                        oneofKind: "requestRelay",
                        requestRelay: RequestRelay.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).requestRelay)
                    };
                    break;
                case /* hbb.RelayResponse relay_response */ 19:
                    message.union = {
                        oneofKind: "relayResponse",
                        relayResponse: RelayResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).relayResponse)
                    };
                    break;
                case /* hbb.TestNatRequest test_nat_request */ 20:
                    message.union = {
                        oneofKind: "testNatRequest",
                        testNatRequest: TestNatRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).testNatRequest)
                    };
                    break;
                case /* hbb.TestNatResponse test_nat_response */ 21:
                    message.union = {
                        oneofKind: "testNatResponse",
                        testNatResponse: TestNatResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).testNatResponse)
                    };
                    break;
                case /* hbb.PeerDiscovery peer_discovery */ 22:
                    message.union = {
                        oneofKind: "peerDiscovery",
                        peerDiscovery: PeerDiscovery.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).peerDiscovery)
                    };
                    break;
                case /* hbb.OnlineRequest online_request */ 23:
                    message.union = {
                        oneofKind: "onlineRequest",
                        onlineRequest: OnlineRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).onlineRequest)
                    };
                    break;
                case /* hbb.OnlineResponse online_response */ 24:
                    message.union = {
                        oneofKind: "onlineResponse",
                        onlineResponse: OnlineResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).onlineResponse)
                    };
                    break;
                case /* hbb.KeyExchange key_exchange */ 25:
                    message.union = {
                        oneofKind: "keyExchange",
                        keyExchange: KeyExchange.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).keyExchange)
                    };
                    break;
                case /* hbb.HealthCheck hc */ 26:
                    message.union = {
                        oneofKind: "hc",
                        hc: HealthCheck.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).hc)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RendezvousMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.RegisterPeer register_peer = 6; */
        if (message.union.oneofKind === "registerPeer")
            RegisterPeer.internalBinaryWrite(message.union.registerPeer, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RegisterPeerResponse register_peer_response = 7; */
        if (message.union.oneofKind === "registerPeerResponse")
            RegisterPeerResponse.internalBinaryWrite(message.union.registerPeerResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PunchHoleRequest punch_hole_request = 8; */
        if (message.union.oneofKind === "punchHoleRequest")
            PunchHoleRequest.internalBinaryWrite(message.union.punchHoleRequest, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PunchHole punch_hole = 9; */
        if (message.union.oneofKind === "punchHole")
            PunchHole.internalBinaryWrite(message.union.punchHole, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PunchHoleSent punch_hole_sent = 10; */
        if (message.union.oneofKind === "punchHoleSent")
            PunchHoleSent.internalBinaryWrite(message.union.punchHoleSent, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PunchHoleResponse punch_hole_response = 11; */
        if (message.union.oneofKind === "punchHoleResponse")
            PunchHoleResponse.internalBinaryWrite(message.union.punchHoleResponse, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FetchLocalAddr fetch_local_addr = 12; */
        if (message.union.oneofKind === "fetchLocalAddr")
            FetchLocalAddr.internalBinaryWrite(message.union.fetchLocalAddr, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* hbb.LocalAddr local_addr = 13; */
        if (message.union.oneofKind === "localAddr")
            LocalAddr.internalBinaryWrite(message.union.localAddr, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ConfigUpdate configure_update = 14; */
        if (message.union.oneofKind === "configureUpdate")
            ConfigUpdate.internalBinaryWrite(message.union.configureUpdate, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RegisterPk register_pk = 15; */
        if (message.union.oneofKind === "registerPk")
            RegisterPk.internalBinaryWrite(message.union.registerPk, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RegisterPkResponse register_pk_response = 16; */
        if (message.union.oneofKind === "registerPkResponse")
            RegisterPkResponse.internalBinaryWrite(message.union.registerPkResponse, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SoftwareUpdate software_update = 17; */
        if (message.union.oneofKind === "softwareUpdate")
            SoftwareUpdate.internalBinaryWrite(message.union.softwareUpdate, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RequestRelay request_relay = 18; */
        if (message.union.oneofKind === "requestRelay")
            RequestRelay.internalBinaryWrite(message.union.requestRelay, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RelayResponse relay_response = 19; */
        if (message.union.oneofKind === "relayResponse")
            RelayResponse.internalBinaryWrite(message.union.relayResponse, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TestNatRequest test_nat_request = 20; */
        if (message.union.oneofKind === "testNatRequest")
            TestNatRequest.internalBinaryWrite(message.union.testNatRequest, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TestNatResponse test_nat_response = 21; */
        if (message.union.oneofKind === "testNatResponse")
            TestNatResponse.internalBinaryWrite(message.union.testNatResponse, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PeerDiscovery peer_discovery = 22; */
        if (message.union.oneofKind === "peerDiscovery")
            PeerDiscovery.internalBinaryWrite(message.union.peerDiscovery, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* hbb.OnlineRequest online_request = 23; */
        if (message.union.oneofKind === "onlineRequest")
            OnlineRequest.internalBinaryWrite(message.union.onlineRequest, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* hbb.OnlineResponse online_response = 24; */
        if (message.union.oneofKind === "onlineResponse")
            OnlineResponse.internalBinaryWrite(message.union.onlineResponse, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* hbb.KeyExchange key_exchange = 25; */
        if (message.union.oneofKind === "keyExchange")
            KeyExchange.internalBinaryWrite(message.union.keyExchange, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* hbb.HealthCheck hc = 26; */
        if (message.union.oneofKind === "hc")
            HealthCheck.internalBinaryWrite(message.union.hc, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RendezvousMessage
 */
export const RendezvousMessage = new RendezvousMessage$Type();
