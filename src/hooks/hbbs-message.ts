// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "message.proto" (package "hbb", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message hbb.EncodedVideoFrame
 */
export interface EncodedVideoFrame {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bool key = 2
     */
    key: boolean;
    /**
     * @generated from protobuf field: int64 pts = 3
     */
    pts: bigint;
}
/**
 * @generated from protobuf message hbb.EncodedVideoFrames
 */
export interface EncodedVideoFrames {
    /**
     * @generated from protobuf field: repeated hbb.EncodedVideoFrame frames = 1
     */
    frames: EncodedVideoFrame[];
}
/**
 * @generated from protobuf message hbb.RGB
 */
export interface RGB {
    /**
     * @generated from protobuf field: bool compress = 1
     */
    compress: boolean;
}
/**
 * planes data send directly in binary for better use arraybuffer on web
 *
 * @generated from protobuf message hbb.YUV
 */
export interface YUV {
    /**
     * @generated from protobuf field: bool compress = 1
     */
    compress: boolean;
    /**
     * @generated from protobuf field: int32 stride = 2
     */
    stride: number;
}
/**
 * @generated from protobuf message hbb.VideoFrame
 */
export interface VideoFrame {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "vp9S";
        /**
         * @generated from protobuf field: hbb.EncodedVideoFrames vp9s = 6
         */
        vp9S: EncodedVideoFrames;
    } | {
        oneofKind: "rgb";
        /**
         * @generated from protobuf field: hbb.RGB rgb = 7
         */
        rgb: RGB;
    } | {
        oneofKind: "yuv";
        /**
         * @generated from protobuf field: hbb.YUV yuv = 8
         */
        yuv: YUV;
    } | {
        oneofKind: "h264S";
        /**
         * @generated from protobuf field: hbb.EncodedVideoFrames h264s = 10
         */
        h264S: EncodedVideoFrames;
    } | {
        oneofKind: "h265S";
        /**
         * @generated from protobuf field: hbb.EncodedVideoFrames h265s = 11
         */
        h265S: EncodedVideoFrames;
    } | {
        oneofKind: "vp8S";
        /**
         * @generated from protobuf field: hbb.EncodedVideoFrames vp8s = 12
         */
        vp8S: EncodedVideoFrames;
    } | {
        oneofKind: "av1S";
        /**
         * @generated from protobuf field: hbb.EncodedVideoFrames av1s = 13
         */
        av1S: EncodedVideoFrames;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: int32 display = 14
     */
    display: number;
}
/**
 * @generated from protobuf message hbb.IdPk
 */
export interface IdPk {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: bytes pk = 2
     */
    pk: Uint8Array;
}
/**
 * @generated from protobuf message hbb.DisplayInfo
 */
export interface DisplayInfo {
    /**
     * @generated from protobuf field: sint32 x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: sint32 y = 2
     */
    y: number;
    /**
     * @generated from protobuf field: int32 width = 3
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 4
     */
    height: number;
    /**
     * @generated from protobuf field: string name = 5
     */
    name: string;
    /**
     * @generated from protobuf field: bool online = 6
     */
    online: boolean;
    /**
     * @generated from protobuf field: bool cursor_embedded = 7
     */
    cursorEmbedded: boolean;
    /**
     * @generated from protobuf field: hbb.Resolution original_resolution = 8
     */
    originalResolution?: Resolution;
    /**
     * @generated from protobuf field: double scale = 9
     */
    scale: number;
}
/**
 * @generated from protobuf message hbb.PortForward
 */
export interface PortForward {
    /**
     * @generated from protobuf field: string host = 1
     */
    host: string;
    /**
     * @generated from protobuf field: int32 port = 2
     */
    port: number;
}
/**
 * @generated from protobuf message hbb.FileTransfer
 */
export interface FileTransfer {
    /**
     * @generated from protobuf field: string dir = 1
     */
    dir: string;
    /**
     * @generated from protobuf field: bool show_hidden = 2
     */
    showHidden: boolean;
}
/**
 * @generated from protobuf message hbb.ViewCamera
 */
export interface ViewCamera {
}
/**
 * @generated from protobuf message hbb.OSLogin
 */
export interface OSLogin {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * @generated from protobuf message hbb.LoginRequest
 */
export interface LoginRequest {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: bytes password = 2
     */
    password: Uint8Array;
    /**
     * @generated from protobuf field: string my_id = 4
     */
    myId: string;
    /**
     * @generated from protobuf field: string my_name = 5
     */
    myName: string;
    /**
     * @generated from protobuf field: hbb.OptionMessage option = 6
     */
    option?: OptionMessage;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "fileTransfer";
        /**
         * @generated from protobuf field: hbb.FileTransfer file_transfer = 7
         */
        fileTransfer: FileTransfer;
    } | {
        oneofKind: "portForward";
        /**
         * @generated from protobuf field: hbb.PortForward port_forward = 8
         */
        portForward: PortForward;
    } | {
        oneofKind: "viewCamera";
        /**
         * @generated from protobuf field: hbb.ViewCamera view_camera = 15
         */
        viewCamera: ViewCamera;
    } | {
        oneofKind: "terminal";
        /**
         * @generated from protobuf field: hbb.Terminal terminal = 16
         */
        terminal: Terminal;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool video_ack_required = 9
     */
    videoAckRequired: boolean;
    /**
     * @generated from protobuf field: uint64 session_id = 10
     */
    sessionId: bigint;
    /**
     * @generated from protobuf field: string version = 11
     */
    version: string;
    /**
     * @generated from protobuf field: hbb.OSLogin os_login = 12
     */
    osLogin?: OSLogin;
    /**
     * @generated from protobuf field: string my_platform = 13
     */
    myPlatform: string;
    /**
     * @generated from protobuf field: bytes hwid = 14
     */
    hwid: Uint8Array;
}
/**
 * @generated from protobuf message hbb.Terminal
 */
export interface Terminal {
    /**
     * @generated from protobuf field: string service_id = 1
     */
    serviceId: string; // Service ID for reconnecting to existing session
}
/**
 * @generated from protobuf message hbb.Auth2FA
 */
export interface Auth2FA {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: bytes hwid = 2
     */
    hwid: Uint8Array;
}
/**
 * @generated from protobuf message hbb.ChatMessage
 */
export interface ChatMessage {
    /**
     * @generated from protobuf field: string text = 1
     */
    text: string;
}
/**
 * @generated from protobuf message hbb.Features
 */
export interface Features {
    /**
     * @generated from protobuf field: bool privacy_mode = 1
     */
    privacyMode: boolean;
    /**
     * @generated from protobuf field: bool terminal = 2
     */
    terminal: boolean;
}
/**
 * @generated from protobuf message hbb.CodecAbility
 */
export interface CodecAbility {
    /**
     * @generated from protobuf field: bool vp8 = 1
     */
    vp8: boolean;
    /**
     * @generated from protobuf field: bool vp9 = 2
     */
    vp9: boolean;
    /**
     * @generated from protobuf field: bool av1 = 3
     */
    av1: boolean;
    /**
     * @generated from protobuf field: bool h264 = 4
     */
    h264: boolean;
    /**
     * @generated from protobuf field: bool h265 = 5
     */
    h265: boolean;
}
/**
 * @generated from protobuf message hbb.SupportedEncoding
 */
export interface SupportedEncoding {
    /**
     * @generated from protobuf field: bool h264 = 1
     */
    h264: boolean;
    /**
     * @generated from protobuf field: bool h265 = 2
     */
    h265: boolean;
    /**
     * @generated from protobuf field: bool vp8 = 3
     */
    vp8: boolean;
    /**
     * @generated from protobuf field: bool av1 = 4
     */
    av1: boolean;
    /**
     * @generated from protobuf field: hbb.CodecAbility i444 = 5
     */
    i444?: CodecAbility;
}
/**
 * @generated from protobuf message hbb.PeerInfo
 */
export interface PeerInfo {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string hostname = 2
     */
    hostname: string;
    /**
     * @generated from protobuf field: string platform = 3
     */
    platform: string;
    /**
     * @generated from protobuf field: repeated hbb.DisplayInfo displays = 4
     */
    displays: DisplayInfo[];
    /**
     * @generated from protobuf field: int32 current_display = 5
     */
    currentDisplay: number;
    /**
     * @generated from protobuf field: bool sas_enabled = 6
     */
    sasEnabled: boolean;
    /**
     * @generated from protobuf field: string version = 7
     */
    version: string;
    /**
     * @generated from protobuf field: hbb.Features features = 9
     */
    features?: Features;
    /**
     * @generated from protobuf field: hbb.SupportedEncoding encoding = 10
     */
    encoding?: SupportedEncoding;
    /**
     * @generated from protobuf field: hbb.SupportedResolutions resolutions = 11
     */
    resolutions?: SupportedResolutions;
    /**
     * Use JSON's key-value format which is friendly for peer to handle.
     * NOTE: Only support one-level dictionaries (for peer to update), and the key is of type string.
     *
     * @generated from protobuf field: string platform_additions = 12
     */
    platformAdditions: string;
    /**
     * @generated from protobuf field: hbb.WindowsSessions windows_sessions = 13
     */
    windowsSessions?: WindowsSessions;
}
/**
 * @generated from protobuf message hbb.WindowsSession
 */
export interface WindowsSession {
    /**
     * @generated from protobuf field: uint32 sid = 1
     */
    sid: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message hbb.LoginResponse
 */
export interface LoginResponse {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "error";
        /**
         * @generated from protobuf field: string error = 1
         */
        error: string;
    } | {
        oneofKind: "peerInfo";
        /**
         * @generated from protobuf field: hbb.PeerInfo peer_info = 2
         */
        peerInfo: PeerInfo;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool enable_trusted_devices = 3
     */
    enableTrustedDevices: boolean;
}
/**
 * @generated from protobuf message hbb.TouchScaleUpdate
 */
export interface TouchScaleUpdate {
    /**
     * The delta scale factor relative to the previous scale.
     * delta * 1000
     * 0 means scale end
     *
     * @generated from protobuf field: int32 scale = 1
     */
    scale: number;
}
/**
 * @generated from protobuf message hbb.TouchPanStart
 */
export interface TouchPanStart {
    /**
     * @generated from protobuf field: int32 x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message hbb.TouchPanUpdate
 */
export interface TouchPanUpdate {
    /**
     * The delta x position relative to the previous position.
     *
     * @generated from protobuf field: int32 x = 1
     */
    x: number;
    /**
     * The delta y position relative to the previous position.
     *
     * @generated from protobuf field: int32 y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message hbb.TouchPanEnd
 */
export interface TouchPanEnd {
    /**
     * @generated from protobuf field: int32 x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: int32 y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message hbb.TouchEvent
 */
export interface TouchEvent {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "scaleUpdate";
        /**
         * @generated from protobuf field: hbb.TouchScaleUpdate scale_update = 1
         */
        scaleUpdate: TouchScaleUpdate;
    } | {
        oneofKind: "panStart";
        /**
         * @generated from protobuf field: hbb.TouchPanStart pan_start = 2
         */
        panStart: TouchPanStart;
    } | {
        oneofKind: "panUpdate";
        /**
         * @generated from protobuf field: hbb.TouchPanUpdate pan_update = 3
         */
        panUpdate: TouchPanUpdate;
    } | {
        oneofKind: "panEnd";
        /**
         * @generated from protobuf field: hbb.TouchPanEnd pan_end = 4
         */
        panEnd: TouchPanEnd;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.PointerDeviceEvent
 */
export interface PointerDeviceEvent {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "touchEvent";
        /**
         * @generated from protobuf field: hbb.TouchEvent touch_event = 1
         */
        touchEvent: TouchEvent;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated hbb.ControlKey modifiers = 2
     */
    modifiers: ControlKey[];
}
/**
 * @generated from protobuf message hbb.MouseEvent
 */
export interface MouseEvent {
    /**
     * @generated from protobuf field: int32 mask = 1
     */
    mask: number;
    /**
     * @generated from protobuf field: sint32 x = 2
     */
    x: number;
    /**
     * @generated from protobuf field: sint32 y = 3
     */
    y: number;
    /**
     * @generated from protobuf field: repeated hbb.ControlKey modifiers = 4
     */
    modifiers: ControlKey[];
}
/**
 * @generated from protobuf message hbb.KeyEvent
 */
export interface KeyEvent {
    /**
     * `down` indicates the key's state(down or up).
     *
     * @generated from protobuf field: bool down = 1
     */
    down: boolean;
    /**
     * `press` indicates a click event(down and up).
     *
     * @generated from protobuf field: bool press = 2
     */
    press: boolean;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "controlKey";
        /**
         * @generated from protobuf field: hbb.ControlKey control_key = 3
         */
        controlKey: ControlKey;
    } | {
        oneofKind: "chr";
        /**
         * position key code. win: scancode, linux: key code, macos: key code
         *
         * @generated from protobuf field: uint32 chr = 4
         */
        chr: number;
    } | {
        oneofKind: "unicode";
        /**
         * @generated from protobuf field: uint32 unicode = 5
         */
        unicode: number;
    } | {
        oneofKind: "seq";
        /**
         * @generated from protobuf field: string seq = 6
         */
        seq: string;
    } | {
        oneofKind: "win2WinHotkey";
        /**
         * high word. virtual keycode
         * low word. unicode
         *
         * @generated from protobuf field: uint32 win2win_hotkey = 7
         */
        win2WinHotkey: number;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated hbb.ControlKey modifiers = 8
     */
    modifiers: ControlKey[];
    /**
     * @generated from protobuf field: hbb.KeyboardMode mode = 9
     */
    mode: KeyboardMode;
}
/**
 * @generated from protobuf message hbb.CursorData
 */
export interface CursorData {
    /**
     * @generated from protobuf field: uint64 id = 1
     */
    id: bigint;
    /**
     * @generated from protobuf field: sint32 hotx = 2
     */
    hotx: number;
    /**
     * @generated from protobuf field: sint32 hoty = 3
     */
    hoty: number;
    /**
     * @generated from protobuf field: int32 width = 4
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 5
     */
    height: number;
    /**
     * @generated from protobuf field: bytes colors = 6
     */
    colors: Uint8Array;
}
/**
 * @generated from protobuf message hbb.CursorPosition
 */
export interface CursorPosition {
    /**
     * @generated from protobuf field: sint32 x = 1
     */
    x: number;
    /**
     * @generated from protobuf field: sint32 y = 2
     */
    y: number;
}
/**
 * @generated from protobuf message hbb.Hash
 */
export interface Hash {
    /**
     * @generated from protobuf field: string salt = 1
     */
    salt: string;
    /**
     * @generated from protobuf field: string challenge = 2
     */
    challenge: string;
}
/**
 * @generated from protobuf message hbb.Clipboard
 */
export interface Clipboard {
    /**
     * @generated from protobuf field: bool compress = 1
     */
    compress: boolean;
    /**
     * @generated from protobuf field: bytes content = 2
     */
    content: Uint8Array;
    /**
     * @generated from protobuf field: int32 width = 3
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 4
     */
    height: number;
    /**
     * @generated from protobuf field: hbb.ClipboardFormat format = 5
     */
    format: ClipboardFormat;
    /**
     * Special format name, only used when format is Special.
     *
     * @generated from protobuf field: string special_name = 6
     */
    specialName: string;
}
/**
 * @generated from protobuf message hbb.MultiClipboards
 */
export interface MultiClipboards {
    /**
     * @generated from protobuf field: repeated hbb.Clipboard clipboards = 1
     */
    clipboards: Clipboard[];
}
/**
 * @generated from protobuf message hbb.FileEntry
 */
export interface FileEntry {
    /**
     * @generated from protobuf field: hbb.FileType entry_type = 1
     */
    entryType: FileType;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_hidden = 3
     */
    isHidden: boolean;
    /**
     * @generated from protobuf field: uint64 size = 4
     */
    size: bigint;
    /**
     * @generated from protobuf field: uint64 modified_time = 5
     */
    modifiedTime: bigint;
}
/**
 * @generated from protobuf message hbb.FileDirectory
 */
export interface FileDirectory {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: repeated hbb.FileEntry entries = 3
     */
    entries: FileEntry[];
}
/**
 * @generated from protobuf message hbb.ReadDir
 */
export interface ReadDir {
    /**
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * @generated from protobuf field: bool include_hidden = 2
     */
    includeHidden: boolean;
}
/**
 * @generated from protobuf message hbb.ReadEmptyDirs
 */
export interface ReadEmptyDirs {
    /**
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * @generated from protobuf field: bool include_hidden = 2
     */
    includeHidden: boolean;
}
/**
 * @generated from protobuf message hbb.ReadEmptyDirsResponse
 */
export interface ReadEmptyDirsResponse {
    /**
     * @generated from protobuf field: string path = 1
     */
    path: string;
    /**
     * @generated from protobuf field: repeated hbb.FileDirectory empty_dirs = 2
     */
    emptyDirs: FileDirectory[];
}
/**
 * @generated from protobuf message hbb.ReadAllFiles
 */
export interface ReadAllFiles {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: bool include_hidden = 3
     */
    includeHidden: boolean;
}
/**
 * @generated from protobuf message hbb.FileRename
 */
export interface FileRename {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: string new_name = 3
     */
    newName: string;
}
/**
 * @generated from protobuf message hbb.FileAction
 */
export interface FileAction {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "readDir";
        /**
         * @generated from protobuf field: hbb.ReadDir read_dir = 1
         */
        readDir: ReadDir;
    } | {
        oneofKind: "send";
        /**
         * @generated from protobuf field: hbb.FileTransferSendRequest send = 2
         */
        send: FileTransferSendRequest;
    } | {
        oneofKind: "receive";
        /**
         * @generated from protobuf field: hbb.FileTransferReceiveRequest receive = 3
         */
        receive: FileTransferReceiveRequest;
    } | {
        oneofKind: "create";
        /**
         * @generated from protobuf field: hbb.FileDirCreate create = 4
         */
        create: FileDirCreate;
    } | {
        oneofKind: "removeDir";
        /**
         * @generated from protobuf field: hbb.FileRemoveDir remove_dir = 5
         */
        removeDir: FileRemoveDir;
    } | {
        oneofKind: "removeFile";
        /**
         * @generated from protobuf field: hbb.FileRemoveFile remove_file = 6
         */
        removeFile: FileRemoveFile;
    } | {
        oneofKind: "allFiles";
        /**
         * @generated from protobuf field: hbb.ReadAllFiles all_files = 7
         */
        allFiles: ReadAllFiles;
    } | {
        oneofKind: "cancel";
        /**
         * @generated from protobuf field: hbb.FileTransferCancel cancel = 8
         */
        cancel: FileTransferCancel;
    } | {
        oneofKind: "sendConfirm";
        /**
         * @generated from protobuf field: hbb.FileTransferSendConfirmRequest send_confirm = 9
         */
        sendConfirm: FileTransferSendConfirmRequest;
    } | {
        oneofKind: "rename";
        /**
         * @generated from protobuf field: hbb.FileRename rename = 10
         */
        rename: FileRename;
    } | {
        oneofKind: "readEmptyDirs";
        /**
         * @generated from protobuf field: hbb.ReadEmptyDirs read_empty_dirs = 11
         */
        readEmptyDirs: ReadEmptyDirs;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.FileTransferCancel
 */
export interface FileTransferCancel {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message hbb.FileResponse
 */
export interface FileResponse {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "dir";
        /**
         * @generated from protobuf field: hbb.FileDirectory dir = 1
         */
        dir: FileDirectory;
    } | {
        oneofKind: "block";
        /**
         * @generated from protobuf field: hbb.FileTransferBlock block = 2
         */
        block: FileTransferBlock;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hbb.FileTransferError error = 3
         */
        error: FileTransferError;
    } | {
        oneofKind: "done";
        /**
         * @generated from protobuf field: hbb.FileTransferDone done = 4
         */
        done: FileTransferDone;
    } | {
        oneofKind: "digest";
        /**
         * @generated from protobuf field: hbb.FileTransferDigest digest = 5
         */
        digest: FileTransferDigest;
    } | {
        oneofKind: "emptyDirs";
        /**
         * @generated from protobuf field: hbb.ReadEmptyDirsResponse empty_dirs = 6
         */
        emptyDirs: ReadEmptyDirsResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.FileTransferDigest
 */
export interface FileTransferDigest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: sint32 file_num = 2
     */
    fileNum: number;
    /**
     * @generated from protobuf field: uint64 last_modified = 3
     */
    lastModified: bigint;
    /**
     * @generated from protobuf field: uint64 file_size = 4
     */
    fileSize: bigint;
    /**
     * @generated from protobuf field: bool is_upload = 5
     */
    isUpload: boolean;
    /**
     * @generated from protobuf field: bool is_identical = 6
     */
    isIdentical: boolean;
    /**
     * @generated from protobuf field: uint64 transferred_size = 7
     */
    transferredSize: bigint; // For resume. Indicates the size of the file already transferred
    /**
     * @generated from protobuf field: bool is_resume = 8
     */
    isResume: boolean; // For resume. Indicates if the transfer is a resume.
}
/**
 * @generated from protobuf message hbb.FileTransferBlock
 */
export interface FileTransferBlock {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: sint32 file_num = 2
     */
    fileNum: number;
    /**
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bool compressed = 4
     */
    compressed: boolean;
    /**
     * @generated from protobuf field: uint32 blk_id = 5
     */
    blkId: number;
}
/**
 * @generated from protobuf message hbb.FileTransferError
 */
export interface FileTransferError {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string error = 2
     */
    error: string;
    /**
     * @generated from protobuf field: sint32 file_num = 3
     */
    fileNum: number;
}
/**
 * @generated from protobuf message hbb.FileTransferSendRequest
 */
export interface FileTransferSendRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: bool include_hidden = 3
     */
    includeHidden: boolean;
    /**
     * @generated from protobuf field: int32 file_num = 4
     */
    fileNum: number;
    /**
     * @generated from protobuf field: hbb.FileTransferSendRequest.FileType file_type = 5
     */
    fileType: FileTransferSendRequest_FileType;
}
/**
 * @generated from protobuf enum hbb.FileTransferSendRequest.FileType
 */
export enum FileTransferSendRequest_FileType {
    /**
     * @generated from protobuf enum value: Generic = 0;
     */
    Generic = 0,
    /**
     * @generated from protobuf enum value: Printer = 1;
     */
    Printer = 1
}
/**
 * @generated from protobuf message hbb.FileTransferSendConfirmRequest
 */
export interface FileTransferSendConfirmRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: sint32 file_num = 2
     */
    fileNum: number;
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "skip";
        /**
         * @generated from protobuf field: bool skip = 3
         */
        skip: boolean;
    } | {
        oneofKind: "offsetBlk";
        /**
         * @generated from protobuf field: uint32 offset_blk = 4
         */
        offsetBlk: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.FileTransferDone
 */
export interface FileTransferDone {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: sint32 file_num = 2
     */
    fileNum: number;
}
/**
 * @generated from protobuf message hbb.FileTransferReceiveRequest
 */
export interface FileTransferReceiveRequest {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string; // path written to
    /**
     * @generated from protobuf field: repeated hbb.FileEntry files = 3
     */
    files: FileEntry[];
    /**
     * @generated from protobuf field: int32 file_num = 4
     */
    fileNum: number;
    /**
     * @generated from protobuf field: uint64 total_size = 5
     */
    totalSize: bigint;
}
/**
 * @generated from protobuf message hbb.FileRemoveDir
 */
export interface FileRemoveDir {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: bool recursive = 3
     */
    recursive: boolean;
}
/**
 * @generated from protobuf message hbb.FileRemoveFile
 */
export interface FileRemoveFile {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
    /**
     * @generated from protobuf field: sint32 file_num = 3
     */
    fileNum: number;
}
/**
 * @generated from protobuf message hbb.FileDirCreate
 */
export interface FileDirCreate {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string path = 2
     */
    path: string;
}
/**
 * main logic from freeRDP
 *
 * @generated from protobuf message hbb.CliprdrMonitorReady
 */
export interface CliprdrMonitorReady {
}
/**
 * @generated from protobuf message hbb.CliprdrFormat
 */
export interface CliprdrFormat {
    /**
     * @generated from protobuf field: int32 id = 2
     */
    id: number;
    /**
     * @generated from protobuf field: string format = 3
     */
    format: string;
}
/**
 * @generated from protobuf message hbb.CliprdrServerFormatList
 */
export interface CliprdrServerFormatList {
    /**
     * @generated from protobuf field: repeated hbb.CliprdrFormat formats = 2
     */
    formats: CliprdrFormat[];
}
/**
 * @generated from protobuf message hbb.CliprdrServerFormatListResponse
 */
export interface CliprdrServerFormatListResponse {
    /**
     * @generated from protobuf field: int32 msg_flags = 2
     */
    msgFlags: number;
}
/**
 * @generated from protobuf message hbb.CliprdrServerFormatDataRequest
 */
export interface CliprdrServerFormatDataRequest {
    /**
     * @generated from protobuf field: int32 requested_format_id = 2
     */
    requestedFormatId: number;
}
/**
 * @generated from protobuf message hbb.CliprdrServerFormatDataResponse
 */
export interface CliprdrServerFormatDataResponse {
    /**
     * @generated from protobuf field: int32 msg_flags = 2
     */
    msgFlags: number;
    /**
     * @generated from protobuf field: bytes format_data = 3
     */
    formatData: Uint8Array;
}
/**
 * @generated from protobuf message hbb.CliprdrFileContentsRequest
 */
export interface CliprdrFileContentsRequest {
    /**
     * @generated from protobuf field: int32 stream_id = 2
     */
    streamId: number;
    /**
     * @generated from protobuf field: int32 list_index = 3
     */
    listIndex: number;
    /**
     * @generated from protobuf field: int32 dw_flags = 4
     */
    dwFlags: number;
    /**
     * @generated from protobuf field: int32 n_position_low = 5
     */
    nPositionLow: number;
    /**
     * @generated from protobuf field: int32 n_position_high = 6
     */
    nPositionHigh: number;
    /**
     * @generated from protobuf field: int32 cb_requested = 7
     */
    cbRequested: number;
    /**
     * @generated from protobuf field: bool have_clip_data_id = 8
     */
    haveClipDataId: boolean;
    /**
     * @generated from protobuf field: int32 clip_data_id = 9
     */
    clipDataId: number;
}
/**
 * @generated from protobuf message hbb.CliprdrFileContentsResponse
 */
export interface CliprdrFileContentsResponse {
    /**
     * @generated from protobuf field: int32 msg_flags = 3
     */
    msgFlags: number;
    /**
     * @generated from protobuf field: int32 stream_id = 4
     */
    streamId: number;
    /**
     * @generated from protobuf field: bytes requested_data = 5
     */
    requestedData: Uint8Array;
}
/**
 * Try empty clipboard in the following case(Windows only):
 * 1. `A`(Windows) -> `B`, `C`
 * 2. Copy in `A, file clipboards on `B` and `C` are updated.
 * 3. Copy in `B`.
 * `A` should tell `C` to empty the file clipboard.
 *
 * @generated from protobuf message hbb.CliprdrTryEmpty
 */
export interface CliprdrTryEmpty {
}
/**
 * Clipobard file message for audit.
 *
 * @generated from protobuf message hbb.CliprdrFile
 */
export interface CliprdrFile {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: uint64 size = 2
     */
    size: bigint;
}
/**
 * @generated from protobuf message hbb.CliprdrFiles
 */
export interface CliprdrFiles {
    /**
     * @generated from protobuf field: repeated hbb.CliprdrFile files = 1
     */
    files: CliprdrFile[];
}
/**
 * @generated from protobuf message hbb.Cliprdr
 */
export interface Cliprdr {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "ready";
        /**
         * @generated from protobuf field: hbb.CliprdrMonitorReady ready = 1
         */
        ready: CliprdrMonitorReady;
    } | {
        oneofKind: "formatList";
        /**
         * @generated from protobuf field: hbb.CliprdrServerFormatList format_list = 2
         */
        formatList: CliprdrServerFormatList;
    } | {
        oneofKind: "formatListResponse";
        /**
         * @generated from protobuf field: hbb.CliprdrServerFormatListResponse format_list_response = 3
         */
        formatListResponse: CliprdrServerFormatListResponse;
    } | {
        oneofKind: "formatDataRequest";
        /**
         * @generated from protobuf field: hbb.CliprdrServerFormatDataRequest format_data_request = 4
         */
        formatDataRequest: CliprdrServerFormatDataRequest;
    } | {
        oneofKind: "formatDataResponse";
        /**
         * @generated from protobuf field: hbb.CliprdrServerFormatDataResponse format_data_response = 5
         */
        formatDataResponse: CliprdrServerFormatDataResponse;
    } | {
        oneofKind: "fileContentsRequest";
        /**
         * @generated from protobuf field: hbb.CliprdrFileContentsRequest file_contents_request = 6
         */
        fileContentsRequest: CliprdrFileContentsRequest;
    } | {
        oneofKind: "fileContentsResponse";
        /**
         * @generated from protobuf field: hbb.CliprdrFileContentsResponse file_contents_response = 7
         */
        fileContentsResponse: CliprdrFileContentsResponse;
    } | {
        oneofKind: "tryEmpty";
        /**
         * @generated from protobuf field: hbb.CliprdrTryEmpty try_empty = 8
         */
        tryEmpty: CliprdrTryEmpty;
    } | {
        oneofKind: "files";
        /**
         * @generated from protobuf field: hbb.CliprdrFiles files = 9
         */
        files: CliprdrFiles;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.Resolution
 */
export interface Resolution {
    /**
     * @generated from protobuf field: int32 width = 1
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 2
     */
    height: number;
}
/**
 * @generated from protobuf message hbb.DisplayResolution
 */
export interface DisplayResolution {
    /**
     * @generated from protobuf field: int32 display = 1
     */
    display: number;
    /**
     * @generated from protobuf field: hbb.Resolution resolution = 2
     */
    resolution?: Resolution;
}
/**
 * @generated from protobuf message hbb.SupportedResolutions
 */
export interface SupportedResolutions {
    /**
     * @generated from protobuf field: repeated hbb.Resolution resolutions = 1
     */
    resolutions: Resolution[];
}
/**
 * @generated from protobuf message hbb.SwitchDisplay
 */
export interface SwitchDisplay {
    /**
     * @generated from protobuf field: int32 display = 1
     */
    display: number;
    /**
     * @generated from protobuf field: sint32 x = 2
     */
    x: number;
    /**
     * @generated from protobuf field: sint32 y = 3
     */
    y: number;
    /**
     * @generated from protobuf field: int32 width = 4
     */
    width: number;
    /**
     * @generated from protobuf field: int32 height = 5
     */
    height: number;
    /**
     * @generated from protobuf field: bool cursor_embedded = 6
     */
    cursorEmbedded: boolean;
    /**
     * @generated from protobuf field: hbb.SupportedResolutions resolutions = 7
     */
    resolutions?: SupportedResolutions;
    /**
     * Do not care about the origin point for now.
     *
     * @generated from protobuf field: hbb.Resolution original_resolution = 8
     */
    originalResolution?: Resolution;
    /**
     * @generated from protobuf field: double scale = 9
     */
    scale: number;
}
/**
 * @generated from protobuf message hbb.CaptureDisplays
 */
export interface CaptureDisplays {
    /**
     * @generated from protobuf field: repeated int32 add = 1
     */
    add: number[];
    /**
     * @generated from protobuf field: repeated int32 sub = 2
     */
    sub: number[];
    /**
     * @generated from protobuf field: repeated int32 set = 3
     */
    set: number[];
}
/**
 * @generated from protobuf message hbb.ToggleVirtualDisplay
 */
export interface ToggleVirtualDisplay {
    /**
     * @generated from protobuf field: int32 display = 1
     */
    display: number;
    /**
     * @generated from protobuf field: bool on = 2
     */
    on: boolean;
}
/**
 * @generated from protobuf message hbb.TogglePrivacyMode
 */
export interface TogglePrivacyMode {
    /**
     * @generated from protobuf field: string impl_key = 1
     */
    implKey: string;
    /**
     * @generated from protobuf field: bool on = 2
     */
    on: boolean;
}
/**
 * @generated from protobuf message hbb.PermissionInfo
 */
export interface PermissionInfo {
    /**
     * @generated from protobuf field: hbb.PermissionInfo.Permission permission = 1
     */
    permission: PermissionInfo_Permission;
    /**
     * @generated from protobuf field: bool enabled = 2
     */
    enabled: boolean;
}
/**
 * @generated from protobuf enum hbb.PermissionInfo.Permission
 */
export enum PermissionInfo_Permission {
    /**
     * @generated from protobuf enum value: Keyboard = 0;
     */
    Keyboard = 0,
    /**
     * @generated from protobuf enum value: Clipboard = 2;
     */
    Clipboard = 2,
    /**
     * @generated from protobuf enum value: Audio = 3;
     */
    Audio = 3,
    /**
     * @generated from protobuf enum value: File = 4;
     */
    File = 4,
    /**
     * @generated from protobuf enum value: Restart = 5;
     */
    Restart = 5,
    /**
     * @generated from protobuf enum value: Recording = 6;
     */
    Recording = 6,
    /**
     * @generated from protobuf enum value: BlockInput = 7;
     */
    BlockInput = 7
}
/**
 * @generated from protobuf message hbb.SupportedDecoding
 */
export interface SupportedDecoding {
    /**
     * @generated from protobuf field: int32 ability_vp9 = 1
     */
    abilityVp9: number;
    /**
     * @generated from protobuf field: int32 ability_h264 = 2
     */
    abilityH264: number;
    /**
     * @generated from protobuf field: int32 ability_h265 = 3
     */
    abilityH265: number;
    /**
     * @generated from protobuf field: hbb.SupportedDecoding.PreferCodec prefer = 4
     */
    prefer: SupportedDecoding_PreferCodec;
    /**
     * @generated from protobuf field: int32 ability_vp8 = 5
     */
    abilityVp8: number;
    /**
     * @generated from protobuf field: int32 ability_av1 = 6
     */
    abilityAv1: number;
    /**
     * @generated from protobuf field: hbb.CodecAbility i444 = 7
     */
    i444?: CodecAbility;
    /**
     * @generated from protobuf field: hbb.Chroma prefer_chroma = 8
     */
    preferChroma: Chroma;
}
/**
 * @generated from protobuf enum hbb.SupportedDecoding.PreferCodec
 */
export enum SupportedDecoding_PreferCodec {
    /**
     * @generated from protobuf enum value: Auto = 0;
     */
    Auto = 0,
    /**
     * @generated from protobuf enum value: VP9 = 1;
     */
    VP9 = 1,
    /**
     * @generated from protobuf enum value: H264 = 2;
     */
    H264 = 2,
    /**
     * @generated from protobuf enum value: H265 = 3;
     */
    H265 = 3,
    /**
     * @generated from protobuf enum value: VP8 = 4;
     */
    VP8 = 4,
    /**
     * @generated from protobuf enum value: AV1 = 5;
     */
    AV1 = 5
}
/**
 * @generated from protobuf message hbb.OptionMessage
 */
export interface OptionMessage {
    /**
     * @generated from protobuf field: hbb.ImageQuality image_quality = 1
     */
    imageQuality: ImageQuality;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption lock_after_session_end = 2
     */
    lockAfterSessionEnd: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption show_remote_cursor = 3
     */
    showRemoteCursor: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption privacy_mode = 4
     */
    privacyMode: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption block_input = 5
     */
    blockInput: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: int32 custom_image_quality = 6
     */
    customImageQuality: number;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption disable_audio = 7
     */
    disableAudio: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption disable_clipboard = 8
     */
    disableClipboard: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption enable_file_transfer = 9
     */
    enableFileTransfer: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.SupportedDecoding supported_decoding = 10
     */
    supportedDecoding?: SupportedDecoding;
    /**
     * @generated from protobuf field: int32 custom_fps = 11
     */
    customFps: number;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption disable_keyboard = 12
     */
    disableKeyboard: OptionMessage_BoolOption;
    /**
     * Position 13 is used for Resolution. Remove later.
     * Resolution custom_resolution = 13;
     * BoolOption support_windows_specific_session = 14;
     * starting from 15 please, do not use removed fields
     *
     * @generated from protobuf field: hbb.OptionMessage.BoolOption follow_remote_cursor = 15
     */
    followRemoteCursor: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption follow_remote_window = 16
     */
    followRemoteWindow: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption disable_camera = 17
     */
    disableCamera: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption terminal_persistent = 18
     */
    terminalPersistent: OptionMessage_BoolOption;
    /**
     * @generated from protobuf field: hbb.OptionMessage.BoolOption show_my_cursor = 19
     */
    showMyCursor: OptionMessage_BoolOption;
}
/**
 * @generated from protobuf enum hbb.OptionMessage.BoolOption
 */
export enum OptionMessage_BoolOption {
    /**
     * @generated from protobuf enum value: NotSet = 0;
     */
    NotSet = 0,
    /**
     * @generated from protobuf enum value: No = 1;
     */
    No = 1,
    /**
     * @generated from protobuf enum value: Yes = 2;
     */
    Yes = 2
}
/**
 * @generated from protobuf message hbb.TestDelay
 */
export interface TestDelay {
    /**
     * @generated from protobuf field: int64 time = 1
     */
    time: bigint;
    /**
     * @generated from protobuf field: bool from_client = 2
     */
    fromClient: boolean;
    /**
     * @generated from protobuf field: uint32 last_delay = 3
     */
    lastDelay: number;
    /**
     * @generated from protobuf field: uint32 target_bitrate = 4
     */
    targetBitrate: number;
}
/**
 * @generated from protobuf message hbb.PublicKey
 */
export interface PublicKey {
    /**
     * @generated from protobuf field: bytes asymmetric_value = 1
     */
    asymmetricValue: Uint8Array;
    /**
     * @generated from protobuf field: bytes symmetric_value = 2
     */
    symmetricValue: Uint8Array;
}
/**
 * @generated from protobuf message hbb.SignedId
 */
export interface SignedId {
    /**
     * @generated from protobuf field: bytes id = 1
     */
    id: Uint8Array;
}
/**
 * @generated from protobuf message hbb.AudioFormat
 */
export interface AudioFormat {
    /**
     * @generated from protobuf field: uint32 sample_rate = 1
     */
    sampleRate: number;
    /**
     * @generated from protobuf field: uint32 channels = 2
     */
    channels: number;
}
/**
 * @generated from protobuf message hbb.AudioFrame
 */
export interface AudioFrame {
    /**
     * @generated from protobuf field: bytes data = 1
     */
    data: Uint8Array;
}
/**
 * Notify peer to show message box.
 *
 * @generated from protobuf message hbb.MessageBox
 */
export interface MessageBox {
    /**
     * Message type. Refer to flutter/lib/common.dart/msgBox().
     *
     * @generated from protobuf field: string msgtype = 1
     */
    msgtype: string;
    /**
     * @generated from protobuf field: string title = 2
     */
    title: string;
    /**
     * English
     *
     * @generated from protobuf field: string text = 3
     */
    text: string;
    /**
     * If not empty, msgbox provides a button to following the link.
     * The link here can't be directly http url.
     * It must be the key of http url configed in peer side or "rustdesk://*" (jump in app).
     *
     * @generated from protobuf field: string link = 4
     */
    link: string;
}
/**
 * @generated from protobuf message hbb.BackNotification
 */
export interface BackNotification {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "privacyModeState";
        /**
         * @generated from protobuf field: hbb.BackNotification.PrivacyModeState privacy_mode_state = 1
         */
        privacyModeState: BackNotification_PrivacyModeState;
    } | {
        oneofKind: "blockInputState";
        /**
         * @generated from protobuf field: hbb.BackNotification.BlockInputState block_input_state = 2
         */
        blockInputState: BackNotification_BlockInputState;
    } | {
        oneofKind: undefined;
    };
    /**
     * Supplementary message, for "PrvOnFailed" and "PrvOffFailed"
     *
     * @generated from protobuf field: string details = 3
     */
    details: string;
    /**
     * The key of the implementation
     *
     * @generated from protobuf field: string impl_key = 4
     */
    implKey: string;
}
/**
 * no need to consider block input by someone else
 *
 * @generated from protobuf enum hbb.BackNotification.BlockInputState
 */
export enum BackNotification_BlockInputState {
    /**
     * @generated from protobuf enum value: BlkStateUnknown = 0;
     */
    BlkStateUnknown = 0,
    /**
     * @generated from protobuf enum value: BlkOnSucceeded = 2;
     */
    BlkOnSucceeded = 2,
    /**
     * @generated from protobuf enum value: BlkOnFailed = 3;
     */
    BlkOnFailed = 3,
    /**
     * @generated from protobuf enum value: BlkOffSucceeded = 4;
     */
    BlkOffSucceeded = 4,
    /**
     * @generated from protobuf enum value: BlkOffFailed = 5;
     */
    BlkOffFailed = 5
}
/**
 * @generated from protobuf enum hbb.BackNotification.PrivacyModeState
 */
export enum BackNotification_PrivacyModeState {
    /**
     * @generated from protobuf enum value: PrvStateUnknown = 0;
     */
    PrvStateUnknown = 0,
    /**
     * Privacy mode on by someone else
     *
     * @generated from protobuf enum value: PrvOnByOther = 2;
     */
    PrvOnByOther = 2,
    /**
     * Privacy mode is not supported on the remote side
     *
     * @generated from protobuf enum value: PrvNotSupported = 3;
     */
    PrvNotSupported = 3,
    /**
     * Privacy mode on by self
     *
     * @generated from protobuf enum value: PrvOnSucceeded = 4;
     */
    PrvOnSucceeded = 4,
    /**
     * Privacy mode on by self, but denied
     *
     * @generated from protobuf enum value: PrvOnFailedDenied = 5;
     */
    PrvOnFailedDenied = 5,
    /**
     * Some plugins are not found
     *
     * @generated from protobuf enum value: PrvOnFailedPlugin = 6;
     */
    PrvOnFailedPlugin = 6,
    /**
     * Privacy mode on by self, but failed
     *
     * @generated from protobuf enum value: PrvOnFailed = 7;
     */
    PrvOnFailed = 7,
    /**
     * Privacy mode off by self
     *
     * @generated from protobuf enum value: PrvOffSucceeded = 8;
     */
    PrvOffSucceeded = 8,
    /**
     * Ctrl + P
     *
     * @generated from protobuf enum value: PrvOffByPeer = 9;
     */
    PrvOffByPeer = 9,
    /**
     * Privacy mode off by self, but failed
     *
     * @generated from protobuf enum value: PrvOffFailed = 10;
     */
    PrvOffFailed = 10,
    /**
     * @generated from protobuf enum value: PrvOffUnknown = 11;
     */
    PrvOffUnknown = 11
}
/**
 * @generated from protobuf message hbb.ElevationRequestWithLogon
 */
export interface ElevationRequestWithLogon {
    /**
     * @generated from protobuf field: string username = 1
     */
    username: string;
    /**
     * @generated from protobuf field: string password = 2
     */
    password: string;
}
/**
 * @generated from protobuf message hbb.ElevationRequest
 */
export interface ElevationRequest {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "direct";
        /**
         * @generated from protobuf field: bool direct = 1
         */
        direct: boolean;
    } | {
        oneofKind: "logon";
        /**
         * @generated from protobuf field: hbb.ElevationRequestWithLogon logon = 2
         */
        logon: ElevationRequestWithLogon;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.SwitchSidesRequest
 */
export interface SwitchSidesRequest {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
}
/**
 * @generated from protobuf message hbb.SwitchSidesResponse
 */
export interface SwitchSidesResponse {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: hbb.LoginRequest lr = 2
     */
    lr?: LoginRequest;
}
/**
 * @generated from protobuf message hbb.SwitchBack
 */
export interface SwitchBack {
}
/**
 * @generated from protobuf message hbb.PluginRequest
 */
export interface PluginRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: bytes content = 2
     */
    content: Uint8Array;
}
/**
 * @generated from protobuf message hbb.PluginFailure
 */
export interface PluginFailure {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string msg = 3
     */
    msg: string;
}
/**
 * @generated from protobuf message hbb.WindowsSessions
 */
export interface WindowsSessions {
    /**
     * @generated from protobuf field: repeated hbb.WindowsSession sessions = 1
     */
    sessions: WindowsSession[];
    /**
     * @generated from protobuf field: uint32 current_sid = 2
     */
    currentSid: number;
}
/**
 * Query messages from peer.
 *
 * @generated from protobuf message hbb.MessageQuery
 */
export interface MessageQuery {
    /**
     * The SwitchDisplay message of the target display.
     * If the target display is not found, the message will be ignored.
     *
     * @generated from protobuf field: int32 switch_display = 1
     */
    switchDisplay: number;
}
/**
 * @generated from protobuf message hbb.Misc
 */
export interface Misc {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "chatMessage";
        /**
         * @generated from protobuf field: hbb.ChatMessage chat_message = 4
         */
        chatMessage: ChatMessage;
    } | {
        oneofKind: "switchDisplay";
        /**
         * @generated from protobuf field: hbb.SwitchDisplay switch_display = 5
         */
        switchDisplay: SwitchDisplay;
    } | {
        oneofKind: "permissionInfo";
        /**
         * @generated from protobuf field: hbb.PermissionInfo permission_info = 6
         */
        permissionInfo: PermissionInfo;
    } | {
        oneofKind: "option";
        /**
         * @generated from protobuf field: hbb.OptionMessage option = 7
         */
        option: OptionMessage;
    } | {
        oneofKind: "audioFormat";
        /**
         * @generated from protobuf field: hbb.AudioFormat audio_format = 8
         */
        audioFormat: AudioFormat;
    } | {
        oneofKind: "closeReason";
        /**
         * @generated from protobuf field: string close_reason = 9
         */
        closeReason: string;
    } | {
        oneofKind: "refreshVideo";
        /**
         * @generated from protobuf field: bool refresh_video = 10
         */
        refreshVideo: boolean;
    } | {
        oneofKind: "videoReceived";
        /**
         * @generated from protobuf field: bool video_received = 12
         */
        videoReceived: boolean;
    } | {
        oneofKind: "backNotification";
        /**
         * @generated from protobuf field: hbb.BackNotification back_notification = 13
         */
        backNotification: BackNotification;
    } | {
        oneofKind: "restartRemoteDevice";
        /**
         * @generated from protobuf field: bool restart_remote_device = 14
         */
        restartRemoteDevice: boolean;
    } | {
        oneofKind: "uac";
        /**
         * @generated from protobuf field: bool uac = 15
         */
        uac: boolean;
    } | {
        oneofKind: "foregroundWindowElevated";
        /**
         * @generated from protobuf field: bool foreground_window_elevated = 16
         */
        foregroundWindowElevated: boolean;
    } | {
        oneofKind: "stopService";
        /**
         * @generated from protobuf field: bool stop_service = 17
         */
        stopService: boolean;
    } | {
        oneofKind: "elevationRequest";
        /**
         * @generated from protobuf field: hbb.ElevationRequest elevation_request = 18
         */
        elevationRequest: ElevationRequest;
    } | {
        oneofKind: "elevationResponse";
        /**
         * @generated from protobuf field: string elevation_response = 19
         */
        elevationResponse: string;
    } | {
        oneofKind: "portableServiceRunning";
        /**
         * @generated from protobuf field: bool portable_service_running = 20
         */
        portableServiceRunning: boolean;
    } | {
        oneofKind: "switchSidesRequest";
        /**
         * @generated from protobuf field: hbb.SwitchSidesRequest switch_sides_request = 21
         */
        switchSidesRequest: SwitchSidesRequest;
    } | {
        oneofKind: "switchBack";
        /**
         * @generated from protobuf field: hbb.SwitchBack switch_back = 22
         */
        switchBack: SwitchBack;
    } | {
        oneofKind: "changeResolution";
        /**
         * Deprecated since 1.2.4, use `change_display_resolution` (36) instead.
         * But we must keep it for compatibility when peer version < 1.2.4.
         *
         * @generated from protobuf field: hbb.Resolution change_resolution = 24
         */
        changeResolution: Resolution;
    } | {
        oneofKind: "pluginRequest";
        /**
         * @generated from protobuf field: hbb.PluginRequest plugin_request = 25
         */
        pluginRequest: PluginRequest;
    } | {
        oneofKind: "pluginFailure";
        /**
         * @generated from protobuf field: hbb.PluginFailure plugin_failure = 26
         */
        pluginFailure: PluginFailure;
    } | {
        oneofKind: "fullSpeedFps";
        /**
         * @generated from protobuf field: uint32 full_speed_fps = 27
         */
        fullSpeedFps: number; // deprecated
    } | {
        oneofKind: "autoAdjustFps";
        /**
         * @generated from protobuf field: uint32 auto_adjust_fps = 28
         */
        autoAdjustFps: number;
    } | {
        oneofKind: "clientRecordStatus";
        /**
         * @generated from protobuf field: bool client_record_status = 29
         */
        clientRecordStatus: boolean;
    } | {
        oneofKind: "captureDisplays";
        /**
         * @generated from protobuf field: hbb.CaptureDisplays capture_displays = 30
         */
        captureDisplays: CaptureDisplays;
    } | {
        oneofKind: "refreshVideoDisplay";
        /**
         * @generated from protobuf field: int32 refresh_video_display = 31
         */
        refreshVideoDisplay: number;
    } | {
        oneofKind: "toggleVirtualDisplay";
        /**
         * @generated from protobuf field: hbb.ToggleVirtualDisplay toggle_virtual_display = 32
         */
        toggleVirtualDisplay: ToggleVirtualDisplay;
    } | {
        oneofKind: "togglePrivacyMode";
        /**
         * @generated from protobuf field: hbb.TogglePrivacyMode toggle_privacy_mode = 33
         */
        togglePrivacyMode: TogglePrivacyMode;
    } | {
        oneofKind: "supportedEncoding";
        /**
         * @generated from protobuf field: hbb.SupportedEncoding supported_encoding = 34
         */
        supportedEncoding: SupportedEncoding;
    } | {
        oneofKind: "selectedSid";
        /**
         * @generated from protobuf field: uint32 selected_sid = 35
         */
        selectedSid: number;
    } | {
        oneofKind: "changeDisplayResolution";
        /**
         * @generated from protobuf field: hbb.DisplayResolution change_display_resolution = 36
         */
        changeDisplayResolution: DisplayResolution;
    } | {
        oneofKind: "messageQuery";
        /**
         * @generated from protobuf field: hbb.MessageQuery message_query = 37
         */
        messageQuery: MessageQuery;
    } | {
        oneofKind: "followCurrentDisplay";
        /**
         * @generated from protobuf field: int32 follow_current_display = 38
         */
        followCurrentDisplay: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.VoiceCallRequest
 */
export interface VoiceCallRequest {
    /**
     * @generated from protobuf field: int64 req_timestamp = 1
     */
    reqTimestamp: bigint;
    /**
     * Indicates whether the request is a connect action or a disconnect action.
     *
     * @generated from protobuf field: bool is_connect = 2
     */
    isConnect: boolean;
}
/**
 * @generated from protobuf message hbb.VoiceCallResponse
 */
export interface VoiceCallResponse {
    /**
     * @generated from protobuf field: bool accepted = 1
     */
    accepted: boolean;
    /**
     * @generated from protobuf field: int64 req_timestamp = 2
     */
    reqTimestamp: bigint; // Should copy from [VoiceCallRequest::req_timestamp].
    /**
     * @generated from protobuf field: int64 ack_timestamp = 3
     */
    ackTimestamp: bigint;
}
/**
 * @generated from protobuf message hbb.ScreenshotRequest
 */
export interface ScreenshotRequest {
    /**
     * @generated from protobuf field: int32 display = 1
     */
    display: number;
    /**
     * sid is the session id on the controlling side
     * It is used to forward the message to the correct remote (session) window.
     *
     * @generated from protobuf field: string sid = 2
     */
    sid: string;
}
/**
 * @generated from protobuf message hbb.ScreenshotResponse
 */
export interface ScreenshotResponse {
    /**
     * @generated from protobuf field: string sid = 1
     */
    sid: string;
    /**
     * empty if success
     *
     * @generated from protobuf field: string msg = 2
     */
    msg: string;
    /**
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array;
}
/**
 * Terminal messages - standalone feature like FileAction
 *
 * @generated from protobuf message hbb.OpenTerminal
 */
export interface OpenTerminal {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number; // 0 for default terminal
    /**
     * @generated from protobuf field: uint32 rows = 2
     */
    rows: number;
    /**
     * @generated from protobuf field: uint32 cols = 3
     */
    cols: number;
}
/**
 * @generated from protobuf message hbb.ResizeTerminal
 */
export interface ResizeTerminal {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
    /**
     * @generated from protobuf field: uint32 rows = 2
     */
    rows: number;
    /**
     * @generated from protobuf field: uint32 cols = 3
     */
    cols: number;
}
/**
 * @generated from protobuf message hbb.TerminalData
 */
export interface TerminalData {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
    /**
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
    /**
     * @generated from protobuf field: bool compressed = 3
     */
    compressed: boolean;
}
/**
 * @generated from protobuf message hbb.CloseTerminal
 */
export interface CloseTerminal {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
}
/**
 * @generated from protobuf message hbb.TerminalAction
 */
export interface TerminalAction {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "open";
        /**
         * @generated from protobuf field: hbb.OpenTerminal open = 1
         */
        open: OpenTerminal;
    } | {
        oneofKind: "data";
        /**
         * @generated from protobuf field: hbb.TerminalData data = 2
         */
        data: TerminalData;
    } | {
        oneofKind: "resize";
        /**
         * @generated from protobuf field: hbb.ResizeTerminal resize = 3
         */
        resize: ResizeTerminal;
    } | {
        oneofKind: "close";
        /**
         * @generated from protobuf field: hbb.CloseTerminal close = 4
         */
        close: CloseTerminal;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.TerminalOpened
 */
export interface TerminalOpened {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
    /**
     * @generated from protobuf field: bool success = 2
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 3
     */
    message: string;
    /**
     * @generated from protobuf field: uint32 pid = 4
     */
    pid: number;
    /**
     * @generated from protobuf field: string service_id = 5
     */
    serviceId: string; // Service ID for persistent sessions
    /**
     * @generated from protobuf field: repeated int32 persistent_sessions = 6
     */
    persistentSessions: number[]; // Used to restore the persistent sessions.
}
/**
 * @generated from protobuf message hbb.TerminalClosed
 */
export interface TerminalClosed {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
    /**
     * @generated from protobuf field: int32 exit_code = 2
     */
    exitCode: number;
}
/**
 * @generated from protobuf message hbb.TerminalError
 */
export interface TerminalError {
    /**
     * @generated from protobuf field: int32 terminal_id = 1
     */
    terminalId: number;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
}
/**
 * @generated from protobuf message hbb.TerminalResponse
 */
export interface TerminalResponse {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "opened";
        /**
         * @generated from protobuf field: hbb.TerminalOpened opened = 1
         */
        opened: TerminalOpened;
    } | {
        oneofKind: "data";
        /**
         * @generated from protobuf field: hbb.TerminalData data = 2
         */
        data: TerminalData;
    } | {
        oneofKind: "closed";
        /**
         * @generated from protobuf field: hbb.TerminalClosed closed = 3
         */
        closed: TerminalClosed;
    } | {
        oneofKind: "error";
        /**
         * @generated from protobuf field: hbb.TerminalError error = 4
         */
        error: TerminalError;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message hbb.Message
 */
export interface Message {
    /**
     * @generated from protobuf oneof: union
     */
    union: {
        oneofKind: "signedId";
        /**
         * @generated from protobuf field: hbb.SignedId signed_id = 3
         */
        signedId: SignedId;
    } | {
        oneofKind: "publicKey";
        /**
         * @generated from protobuf field: hbb.PublicKey public_key = 4
         */
        publicKey: PublicKey;
    } | {
        oneofKind: "testDelay";
        /**
         * @generated from protobuf field: hbb.TestDelay test_delay = 5
         */
        testDelay: TestDelay;
    } | {
        oneofKind: "videoFrame";
        /**
         * @generated from protobuf field: hbb.VideoFrame video_frame = 6
         */
        videoFrame: VideoFrame;
    } | {
        oneofKind: "loginRequest";
        /**
         * @generated from protobuf field: hbb.LoginRequest login_request = 7
         */
        loginRequest: LoginRequest;
    } | {
        oneofKind: "loginResponse";
        /**
         * @generated from protobuf field: hbb.LoginResponse login_response = 8
         */
        loginResponse: LoginResponse;
    } | {
        oneofKind: "hash";
        /**
         * @generated from protobuf field: hbb.Hash hash = 9
         */
        hash: Hash;
    } | {
        oneofKind: "mouseEvent";
        /**
         * @generated from protobuf field: hbb.MouseEvent mouse_event = 10
         */
        mouseEvent: MouseEvent;
    } | {
        oneofKind: "audioFrame";
        /**
         * @generated from protobuf field: hbb.AudioFrame audio_frame = 11
         */
        audioFrame: AudioFrame;
    } | {
        oneofKind: "cursorData";
        /**
         * @generated from protobuf field: hbb.CursorData cursor_data = 12
         */
        cursorData: CursorData;
    } | {
        oneofKind: "cursorPosition";
        /**
         * @generated from protobuf field: hbb.CursorPosition cursor_position = 13
         */
        cursorPosition: CursorPosition;
    } | {
        oneofKind: "cursorId";
        /**
         * @generated from protobuf field: uint64 cursor_id = 14
         */
        cursorId: bigint;
    } | {
        oneofKind: "keyEvent";
        /**
         * @generated from protobuf field: hbb.KeyEvent key_event = 15
         */
        keyEvent: KeyEvent;
    } | {
        oneofKind: "clipboard";
        /**
         * @generated from protobuf field: hbb.Clipboard clipboard = 16
         */
        clipboard: Clipboard;
    } | {
        oneofKind: "fileAction";
        /**
         * @generated from protobuf field: hbb.FileAction file_action = 17
         */
        fileAction: FileAction;
    } | {
        oneofKind: "fileResponse";
        /**
         * @generated from protobuf field: hbb.FileResponse file_response = 18
         */
        fileResponse: FileResponse;
    } | {
        oneofKind: "misc";
        /**
         * @generated from protobuf field: hbb.Misc misc = 19
         */
        misc: Misc;
    } | {
        oneofKind: "cliprdr";
        /**
         * @generated from protobuf field: hbb.Cliprdr cliprdr = 20
         */
        cliprdr: Cliprdr;
    } | {
        oneofKind: "messageBox";
        /**
         * @generated from protobuf field: hbb.MessageBox message_box = 21
         */
        messageBox: MessageBox;
    } | {
        oneofKind: "switchSidesResponse";
        /**
         * @generated from protobuf field: hbb.SwitchSidesResponse switch_sides_response = 22
         */
        switchSidesResponse: SwitchSidesResponse;
    } | {
        oneofKind: "voiceCallRequest";
        /**
         * @generated from protobuf field: hbb.VoiceCallRequest voice_call_request = 23
         */
        voiceCallRequest: VoiceCallRequest;
    } | {
        oneofKind: "voiceCallResponse";
        /**
         * @generated from protobuf field: hbb.VoiceCallResponse voice_call_response = 24
         */
        voiceCallResponse: VoiceCallResponse;
    } | {
        oneofKind: "peerInfo";
        /**
         * @generated from protobuf field: hbb.PeerInfo peer_info = 25
         */
        peerInfo: PeerInfo;
    } | {
        oneofKind: "pointerDeviceEvent";
        /**
         * @generated from protobuf field: hbb.PointerDeviceEvent pointer_device_event = 26
         */
        pointerDeviceEvent: PointerDeviceEvent;
    } | {
        oneofKind: "auth2Fa";
        /**
         * @generated from protobuf field: hbb.Auth2FA auth_2fa = 27
         */
        auth2Fa: Auth2FA;
    } | {
        oneofKind: "multiClipboards";
        /**
         * @generated from protobuf field: hbb.MultiClipboards multi_clipboards = 28
         */
        multiClipboards: MultiClipboards;
    } | {
        oneofKind: "screenshotRequest";
        /**
         * @generated from protobuf field: hbb.ScreenshotRequest screenshot_request = 29
         */
        screenshotRequest: ScreenshotRequest;
    } | {
        oneofKind: "screenshotResponse";
        /**
         * @generated from protobuf field: hbb.ScreenshotResponse screenshot_response = 30
         */
        screenshotResponse: ScreenshotResponse;
    } | {
        oneofKind: "terminalAction";
        /**
         * @generated from protobuf field: hbb.TerminalAction terminal_action = 31
         */
        terminalAction: TerminalAction;
    } | {
        oneofKind: "terminalResponse";
        /**
         * @generated from protobuf field: hbb.TerminalResponse terminal_response = 32
         */
        terminalResponse: TerminalResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum hbb.Chroma
 */
export enum Chroma {
    /**
     * @generated from protobuf enum value: I420 = 0;
     */
    I420 = 0,
    /**
     * @generated from protobuf enum value: I444 = 1;
     */
    I444 = 1
}
/**
 * @generated from protobuf enum hbb.KeyboardMode
 */
export enum KeyboardMode {
    /**
     * @generated from protobuf enum value: Legacy = 0;
     */
    Legacy = 0,
    /**
     * @generated from protobuf enum value: Map = 1;
     */
    Map = 1,
    /**
     * @generated from protobuf enum value: Translate = 2;
     */
    Translate = 2,
    /**
     * @generated from protobuf enum value: Auto = 3;
     */
    Auto = 3
}
/**
 * @generated from protobuf enum hbb.ControlKey
 */
export enum ControlKey {
    /**
     * @generated from protobuf enum value: Unknown = 0;
     */
    Unknown = 0,
    /**
     * @generated from protobuf enum value: Alt = 1;
     */
    Alt = 1,
    /**
     * @generated from protobuf enum value: Backspace = 2;
     */
    Backspace = 2,
    /**
     * @generated from protobuf enum value: CapsLock = 3;
     */
    CapsLock = 3,
    /**
     * @generated from protobuf enum value: Control = 4;
     */
    Control = 4,
    /**
     * @generated from protobuf enum value: Delete = 5;
     */
    Delete = 5,
    /**
     * @generated from protobuf enum value: DownArrow = 6;
     */
    DownArrow = 6,
    /**
     * @generated from protobuf enum value: End = 7;
     */
    End = 7,
    /**
     * @generated from protobuf enum value: Escape = 8;
     */
    Escape = 8,
    /**
     * @generated from protobuf enum value: F1 = 9;
     */
    F1 = 9,
    /**
     * @generated from protobuf enum value: F10 = 10;
     */
    F10 = 10,
    /**
     * @generated from protobuf enum value: F11 = 11;
     */
    F11 = 11,
    /**
     * @generated from protobuf enum value: F12 = 12;
     */
    F12 = 12,
    /**
     * @generated from protobuf enum value: F2 = 13;
     */
    F2 = 13,
    /**
     * @generated from protobuf enum value: F3 = 14;
     */
    F3 = 14,
    /**
     * @generated from protobuf enum value: F4 = 15;
     */
    F4 = 15,
    /**
     * @generated from protobuf enum value: F5 = 16;
     */
    F5 = 16,
    /**
     * @generated from protobuf enum value: F6 = 17;
     */
    F6 = 17,
    /**
     * @generated from protobuf enum value: F7 = 18;
     */
    F7 = 18,
    /**
     * @generated from protobuf enum value: F8 = 19;
     */
    F8 = 19,
    /**
     * @generated from protobuf enum value: F9 = 20;
     */
    F9 = 20,
    /**
     * @generated from protobuf enum value: Home = 21;
     */
    Home = 21,
    /**
     * @generated from protobuf enum value: LeftArrow = 22;
     */
    LeftArrow = 22,
    /**
     * / meta key (also known as "windows"; "super"; and "command")
     *
     * @generated from protobuf enum value: Meta = 23;
     */
    Meta = 23,
    /**
     * / option key on macOS (alt key on Linux and Windows)
     *
     * deprecated, use Alt instead
     *
     * @generated from protobuf enum value: Option = 24;
     */
    Option = 24,
    /**
     * @generated from protobuf enum value: PageDown = 25;
     */
    PageDown = 25,
    /**
     * @generated from protobuf enum value: PageUp = 26;
     */
    PageUp = 26,
    /**
     * @generated from protobuf enum value: Return = 27;
     */
    Return = 27,
    /**
     * @generated from protobuf enum value: RightArrow = 28;
     */
    RightArrow = 28,
    /**
     * @generated from protobuf enum value: Shift = 29;
     */
    Shift = 29,
    /**
     * @generated from protobuf enum value: Space = 30;
     */
    Space = 30,
    /**
     * @generated from protobuf enum value: Tab = 31;
     */
    Tab = 31,
    /**
     * @generated from protobuf enum value: UpArrow = 32;
     */
    UpArrow = 32,
    /**
     * @generated from protobuf enum value: Numpad0 = 33;
     */
    Numpad0 = 33,
    /**
     * @generated from protobuf enum value: Numpad1 = 34;
     */
    Numpad1 = 34,
    /**
     * @generated from protobuf enum value: Numpad2 = 35;
     */
    Numpad2 = 35,
    /**
     * @generated from protobuf enum value: Numpad3 = 36;
     */
    Numpad3 = 36,
    /**
     * @generated from protobuf enum value: Numpad4 = 37;
     */
    Numpad4 = 37,
    /**
     * @generated from protobuf enum value: Numpad5 = 38;
     */
    Numpad5 = 38,
    /**
     * @generated from protobuf enum value: Numpad6 = 39;
     */
    Numpad6 = 39,
    /**
     * @generated from protobuf enum value: Numpad7 = 40;
     */
    Numpad7 = 40,
    /**
     * @generated from protobuf enum value: Numpad8 = 41;
     */
    Numpad8 = 41,
    /**
     * @generated from protobuf enum value: Numpad9 = 42;
     */
    Numpad9 = 42,
    /**
     * @generated from protobuf enum value: Cancel = 43;
     */
    Cancel = 43,
    /**
     * @generated from protobuf enum value: Clear = 44;
     */
    Clear = 44,
    /**
     * deprecated, use Alt instead
     *
     * @generated from protobuf enum value: Menu = 45;
     */
    Menu = 45,
    /**
     * @generated from protobuf enum value: Pause = 46;
     */
    Pause = 46,
    /**
     * @generated from protobuf enum value: Kana = 47;
     */
    Kana = 47,
    /**
     * @generated from protobuf enum value: Hangul = 48;
     */
    Hangul = 48,
    /**
     * @generated from protobuf enum value: Junja = 49;
     */
    Junja = 49,
    /**
     * @generated from protobuf enum value: Final = 50;
     */
    Final = 50,
    /**
     * @generated from protobuf enum value: Hanja = 51;
     */
    Hanja = 51,
    /**
     * @generated from protobuf enum value: Kanji = 52;
     */
    Kanji = 52,
    /**
     * @generated from protobuf enum value: Convert = 53;
     */
    Convert = 53,
    /**
     * @generated from protobuf enum value: Select = 54;
     */
    Select = 54,
    /**
     * @generated from protobuf enum value: Print = 55;
     */
    Print = 55,
    /**
     * @generated from protobuf enum value: Execute = 56;
     */
    Execute = 56,
    /**
     * @generated from protobuf enum value: Snapshot = 57;
     */
    Snapshot = 57,
    /**
     * @generated from protobuf enum value: Insert = 58;
     */
    Insert = 58,
    /**
     * @generated from protobuf enum value: Help = 59;
     */
    Help = 59,
    /**
     * @generated from protobuf enum value: Sleep = 60;
     */
    Sleep = 60,
    /**
     * @generated from protobuf enum value: Separator = 61;
     */
    Separator = 61,
    /**
     * @generated from protobuf enum value: Scroll = 62;
     */
    Scroll = 62,
    /**
     * @generated from protobuf enum value: NumLock = 63;
     */
    NumLock = 63,
    /**
     * @generated from protobuf enum value: RWin = 64;
     */
    RWin = 64,
    /**
     * @generated from protobuf enum value: Apps = 65;
     */
    Apps = 65,
    /**
     * @generated from protobuf enum value: Multiply = 66;
     */
    Multiply = 66,
    /**
     * @generated from protobuf enum value: Add = 67;
     */
    Add = 67,
    /**
     * @generated from protobuf enum value: Subtract = 68;
     */
    Subtract = 68,
    /**
     * @generated from protobuf enum value: Decimal = 69;
     */
    Decimal = 69,
    /**
     * @generated from protobuf enum value: Divide = 70;
     */
    Divide = 70,
    /**
     * @generated from protobuf enum value: Equals = 71;
     */
    Equals = 71,
    /**
     * @generated from protobuf enum value: NumpadEnter = 72;
     */
    NumpadEnter = 72,
    /**
     * @generated from protobuf enum value: RShift = 73;
     */
    RShift = 73,
    /**
     * @generated from protobuf enum value: RControl = 74;
     */
    RControl = 74,
    /**
     * @generated from protobuf enum value: RAlt = 75;
     */
    RAlt = 75,
    /**
     * mainly used on mobile devices as controlled side
     *
     * @generated from protobuf enum value: VolumeMute = 76;
     */
    VolumeMute = 76,
    /**
     * @generated from protobuf enum value: VolumeUp = 77;
     */
    VolumeUp = 77,
    /**
     * @generated from protobuf enum value: VolumeDown = 78;
     */
    VolumeDown = 78,
    /**
     * mainly used on mobile devices as controlled side
     *
     * @generated from protobuf enum value: Power = 79;
     */
    Power = 79,
    /**
     * @generated from protobuf enum value: CtrlAltDel = 100;
     */
    CtrlAltDel = 100,
    /**
     * @generated from protobuf enum value: LockScreen = 101;
     */
    LockScreen = 101
}
/**
 * @generated from protobuf enum hbb.ClipboardFormat
 */
export enum ClipboardFormat {
    /**
     * @generated from protobuf enum value: Text = 0;
     */
    Text = 0,
    /**
     * @generated from protobuf enum value: Rtf = 1;
     */
    Rtf = 1,
    /**
     * @generated from protobuf enum value: Html = 2;
     */
    Html = 2,
    /**
     * @generated from protobuf enum value: ImageRgba = 21;
     */
    ImageRgba = 21,
    /**
     * @generated from protobuf enum value: ImagePng = 22;
     */
    ImagePng = 22,
    /**
     * @generated from protobuf enum value: ImageSvg = 23;
     */
    ImageSvg = 23,
    /**
     * @generated from protobuf enum value: Special = 31;
     */
    Special = 31
}
/**
 * @generated from protobuf enum hbb.FileType
 */
export enum FileType {
    /**
     * @generated from protobuf enum value: Dir = 0;
     */
    Dir = 0,
    /**
     * @generated from protobuf enum value: DirLink = 2;
     */
    DirLink = 2,
    /**
     * @generated from protobuf enum value: DirDrive = 3;
     */
    DirDrive = 3,
    /**
     * @generated from protobuf enum value: File = 4;
     */
    File = 4,
    /**
     * @generated from protobuf enum value: FileLink = 5;
     */
    FileLink = 5
}
/**
 * @generated from protobuf enum hbb.ImageQuality
 */
export enum ImageQuality {
    /**
     * @generated from protobuf enum value: NotSet = 0;
     */
    NotSet = 0,
    /**
     * @generated from protobuf enum value: Low = 2;
     */
    Low = 2,
    /**
     * @generated from protobuf enum value: Balanced = 3;
     */
    Balanced = 3,
    /**
     * @generated from protobuf enum value: Best = 4;
     */
    Best = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class EncodedVideoFrame$Type extends MessageType<EncodedVideoFrame> {
    constructor() {
        super("hbb.EncodedVideoFrame", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "key", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "pts", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EncodedVideoFrame>): EncodedVideoFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        message.key = false;
        message.pts = 0n;
        if (value !== undefined)
            reflectionMergePartial<EncodedVideoFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncodedVideoFrame): EncodedVideoFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                case /* bool key */ 2:
                    message.key = reader.bool();
                    break;
                case /* int64 pts */ 3:
                    message.pts = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncodedVideoFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        /* bool key = 2; */
        if (message.key !== false)
            writer.tag(2, WireType.Varint).bool(message.key);
        /* int64 pts = 3; */
        if (message.pts !== 0n)
            writer.tag(3, WireType.Varint).int64(message.pts);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.EncodedVideoFrame
 */
export const EncodedVideoFrame = new EncodedVideoFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EncodedVideoFrames$Type extends MessageType<EncodedVideoFrames> {
    constructor() {
        super("hbb.EncodedVideoFrames", [
            { no: 1, name: "frames", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EncodedVideoFrame }
        ]);
    }
    create(value?: PartialMessage<EncodedVideoFrames>): EncodedVideoFrames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frames = [];
        if (value !== undefined)
            reflectionMergePartial<EncodedVideoFrames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EncodedVideoFrames): EncodedVideoFrames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.EncodedVideoFrame frames */ 1:
                    message.frames.push(EncodedVideoFrame.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EncodedVideoFrames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.EncodedVideoFrame frames = 1; */
        for (let i = 0; i < message.frames.length; i++)
            EncodedVideoFrame.internalBinaryWrite(message.frames[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.EncodedVideoFrames
 */
export const EncodedVideoFrames = new EncodedVideoFrames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RGB$Type extends MessageType<RGB> {
    constructor() {
        super("hbb.RGB", [
            { no: 1, name: "compress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<RGB>): RGB {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compress = false;
        if (value !== undefined)
            reflectionMergePartial<RGB>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RGB): RGB {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool compress */ 1:
                    message.compress = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RGB, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool compress = 1; */
        if (message.compress !== false)
            writer.tag(1, WireType.Varint).bool(message.compress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.RGB
 */
export const RGB = new RGB$Type();
// @generated message type with reflection information, may provide speed optimized methods
class YUV$Type extends MessageType<YUV> {
    constructor() {
        super("hbb.YUV", [
            { no: 1, name: "compress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "stride", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<YUV>): YUV {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compress = false;
        message.stride = 0;
        if (value !== undefined)
            reflectionMergePartial<YUV>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: YUV): YUV {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool compress */ 1:
                    message.compress = reader.bool();
                    break;
                case /* int32 stride */ 2:
                    message.stride = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: YUV, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool compress = 1; */
        if (message.compress !== false)
            writer.tag(1, WireType.Varint).bool(message.compress);
        /* int32 stride = 2; */
        if (message.stride !== 0)
            writer.tag(2, WireType.Varint).int32(message.stride);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.YUV
 */
export const YUV = new YUV$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VideoFrame$Type extends MessageType<VideoFrame> {
    constructor() {
        super("hbb.VideoFrame", [
            { no: 6, name: "vp9s", kind: "message", jsonName: "vp9s", oneof: "union", T: () => EncodedVideoFrames },
            { no: 7, name: "rgb", kind: "message", oneof: "union", T: () => RGB },
            { no: 8, name: "yuv", kind: "message", oneof: "union", T: () => YUV },
            { no: 10, name: "h264s", kind: "message", jsonName: "h264s", oneof: "union", T: () => EncodedVideoFrames },
            { no: 11, name: "h265s", kind: "message", jsonName: "h265s", oneof: "union", T: () => EncodedVideoFrames },
            { no: 12, name: "vp8s", kind: "message", jsonName: "vp8s", oneof: "union", T: () => EncodedVideoFrames },
            { no: 13, name: "av1s", kind: "message", jsonName: "av1s", oneof: "union", T: () => EncodedVideoFrames },
            { no: 14, name: "display", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<VideoFrame>): VideoFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        message.display = 0;
        if (value !== undefined)
            reflectionMergePartial<VideoFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VideoFrame): VideoFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.EncodedVideoFrames vp9s */ 6:
                    message.union = {
                        oneofKind: "vp9S",
                        vp9S: EncodedVideoFrames.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).vp9S)
                    };
                    break;
                case /* hbb.RGB rgb */ 7:
                    message.union = {
                        oneofKind: "rgb",
                        rgb: RGB.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).rgb)
                    };
                    break;
                case /* hbb.YUV yuv */ 8:
                    message.union = {
                        oneofKind: "yuv",
                        yuv: YUV.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).yuv)
                    };
                    break;
                case /* hbb.EncodedVideoFrames h264s */ 10:
                    message.union = {
                        oneofKind: "h264S",
                        h264S: EncodedVideoFrames.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).h264S)
                    };
                    break;
                case /* hbb.EncodedVideoFrames h265s */ 11:
                    message.union = {
                        oneofKind: "h265S",
                        h265S: EncodedVideoFrames.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).h265S)
                    };
                    break;
                case /* hbb.EncodedVideoFrames vp8s */ 12:
                    message.union = {
                        oneofKind: "vp8S",
                        vp8S: EncodedVideoFrames.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).vp8S)
                    };
                    break;
                case /* hbb.EncodedVideoFrames av1s */ 13:
                    message.union = {
                        oneofKind: "av1S",
                        av1S: EncodedVideoFrames.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).av1S)
                    };
                    break;
                case /* int32 display */ 14:
                    message.display = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VideoFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.EncodedVideoFrames vp9s = 6; */
        if (message.union.oneofKind === "vp9S")
            EncodedVideoFrames.internalBinaryWrite(message.union.vp9S, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.RGB rgb = 7; */
        if (message.union.oneofKind === "rgb")
            RGB.internalBinaryWrite(message.union.rgb, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.YUV yuv = 8; */
        if (message.union.oneofKind === "yuv")
            YUV.internalBinaryWrite(message.union.yuv, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hbb.EncodedVideoFrames h264s = 10; */
        if (message.union.oneofKind === "h264S")
            EncodedVideoFrames.internalBinaryWrite(message.union.h264S, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* hbb.EncodedVideoFrames h265s = 11; */
        if (message.union.oneofKind === "h265S")
            EncodedVideoFrames.internalBinaryWrite(message.union.h265S, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* hbb.EncodedVideoFrames vp8s = 12; */
        if (message.union.oneofKind === "vp8S")
            EncodedVideoFrames.internalBinaryWrite(message.union.vp8S, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* hbb.EncodedVideoFrames av1s = 13; */
        if (message.union.oneofKind === "av1S")
            EncodedVideoFrames.internalBinaryWrite(message.union.av1S, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* int32 display = 14; */
        if (message.display !== 0)
            writer.tag(14, WireType.Varint).int32(message.display);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.VideoFrame
 */
export const VideoFrame = new VideoFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IdPk$Type extends MessageType<IdPk> {
    constructor() {
        super("hbb.IdPk", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pk", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<IdPk>): IdPk {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.pk = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<IdPk>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IdPk): IdPk {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes pk */ 2:
                    message.pk = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IdPk, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes pk = 2; */
        if (message.pk.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.pk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.IdPk
 */
export const IdPk = new IdPk$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayInfo$Type extends MessageType<DisplayInfo> {
    constructor() {
        super("hbb.DisplayInfo", [
            { no: 1, name: "x", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "online", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "cursor_embedded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "original_resolution", kind: "message", T: () => Resolution },
            { no: 9, name: "scale", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DisplayInfo>): DisplayInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.height = 0;
        message.name = "";
        message.online = false;
        message.cursorEmbedded = false;
        message.scale = 0;
        if (value !== undefined)
            reflectionMergePartial<DisplayInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayInfo): DisplayInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 x */ 1:
                    message.x = reader.sint32();
                    break;
                case /* sint32 y */ 2:
                    message.y = reader.sint32();
                    break;
                case /* int32 width */ 3:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 4:
                    message.height = reader.int32();
                    break;
                case /* string name */ 5:
                    message.name = reader.string();
                    break;
                case /* bool online */ 6:
                    message.online = reader.bool();
                    break;
                case /* bool cursor_embedded */ 7:
                    message.cursorEmbedded = reader.bool();
                    break;
                case /* hbb.Resolution original_resolution */ 8:
                    message.originalResolution = Resolution.internalBinaryRead(reader, reader.uint32(), options, message.originalResolution);
                    break;
                case /* double scale */ 9:
                    message.scale = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).sint32(message.x);
        /* sint32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).sint32(message.y);
        /* int32 width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Varint).int32(message.width);
        /* int32 height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Varint).int32(message.height);
        /* string name = 5; */
        if (message.name !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.name);
        /* bool online = 6; */
        if (message.online !== false)
            writer.tag(6, WireType.Varint).bool(message.online);
        /* bool cursor_embedded = 7; */
        if (message.cursorEmbedded !== false)
            writer.tag(7, WireType.Varint).bool(message.cursorEmbedded);
        /* hbb.Resolution original_resolution = 8; */
        if (message.originalResolution)
            Resolution.internalBinaryWrite(message.originalResolution, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* double scale = 9; */
        if (message.scale !== 0)
            writer.tag(9, WireType.Bit64).double(message.scale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.DisplayInfo
 */
export const DisplayInfo = new DisplayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortForward$Type extends MessageType<PortForward> {
    constructor() {
        super("hbb.PortForward", [
            { no: 1, name: "host", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "port", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PortForward>): PortForward {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.host = "";
        message.port = 0;
        if (value !== undefined)
            reflectionMergePartial<PortForward>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortForward): PortForward {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string host */ 1:
                    message.host = reader.string();
                    break;
                case /* int32 port */ 2:
                    message.port = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortForward, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string host = 1; */
        if (message.host !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.host);
        /* int32 port = 2; */
        if (message.port !== 0)
            writer.tag(2, WireType.Varint).int32(message.port);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PortForward
 */
export const PortForward = new PortForward$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransfer$Type extends MessageType<FileTransfer> {
    constructor() {
        super("hbb.FileTransfer", [
            { no: 1, name: "dir", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "show_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransfer>): FileTransfer {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.dir = "";
        message.showHidden = false;
        if (value !== undefined)
            reflectionMergePartial<FileTransfer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransfer): FileTransfer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string dir */ 1:
                    message.dir = reader.string();
                    break;
                case /* bool show_hidden */ 2:
                    message.showHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransfer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string dir = 1; */
        if (message.dir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.dir);
        /* bool show_hidden = 2; */
        if (message.showHidden !== false)
            writer.tag(2, WireType.Varint).bool(message.showHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransfer
 */
export const FileTransfer = new FileTransfer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ViewCamera$Type extends MessageType<ViewCamera> {
    constructor() {
        super("hbb.ViewCamera", []);
    }
    create(value?: PartialMessage<ViewCamera>): ViewCamera {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ViewCamera>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ViewCamera): ViewCamera {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ViewCamera, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ViewCamera
 */
export const ViewCamera = new ViewCamera$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OSLogin$Type extends MessageType<OSLogin> {
    constructor() {
        super("hbb.OSLogin", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OSLogin>): OSLogin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<OSLogin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OSLogin): OSLogin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OSLogin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.OSLogin
 */
export const OSLogin = new OSLogin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginRequest$Type extends MessageType<LoginRequest> {
    constructor() {
        super("hbb.LoginRequest", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "my_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "my_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "option", kind: "message", T: () => OptionMessage },
            { no: 7, name: "file_transfer", kind: "message", oneof: "union", T: () => FileTransfer },
            { no: 8, name: "port_forward", kind: "message", oneof: "union", T: () => PortForward },
            { no: 15, name: "view_camera", kind: "message", oneof: "union", T: () => ViewCamera },
            { no: 16, name: "terminal", kind: "message", oneof: "union", T: () => Terminal },
            { no: 9, name: "video_ack_required", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "session_id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "os_login", kind: "message", T: () => OSLogin },
            { no: 13, name: "my_platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "hwid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<LoginRequest>): LoginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = new Uint8Array(0);
        message.myId = "";
        message.myName = "";
        message.union = { oneofKind: undefined };
        message.videoAckRequired = false;
        message.sessionId = 0n;
        message.version = "";
        message.myPlatform = "";
        message.hwid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<LoginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginRequest): LoginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* bytes password */ 2:
                    message.password = reader.bytes();
                    break;
                case /* string my_id */ 4:
                    message.myId = reader.string();
                    break;
                case /* string my_name */ 5:
                    message.myName = reader.string();
                    break;
                case /* hbb.OptionMessage option */ 6:
                    message.option = OptionMessage.internalBinaryRead(reader, reader.uint32(), options, message.option);
                    break;
                case /* hbb.FileTransfer file_transfer */ 7:
                    message.union = {
                        oneofKind: "fileTransfer",
                        fileTransfer: FileTransfer.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fileTransfer)
                    };
                    break;
                case /* hbb.PortForward port_forward */ 8:
                    message.union = {
                        oneofKind: "portForward",
                        portForward: PortForward.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).portForward)
                    };
                    break;
                case /* hbb.ViewCamera view_camera */ 15:
                    message.union = {
                        oneofKind: "viewCamera",
                        viewCamera: ViewCamera.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).viewCamera)
                    };
                    break;
                case /* hbb.Terminal terminal */ 16:
                    message.union = {
                        oneofKind: "terminal",
                        terminal: Terminal.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).terminal)
                    };
                    break;
                case /* bool video_ack_required */ 9:
                    message.videoAckRequired = reader.bool();
                    break;
                case /* uint64 session_id */ 10:
                    message.sessionId = reader.uint64().toBigInt();
                    break;
                case /* string version */ 11:
                    message.version = reader.string();
                    break;
                case /* hbb.OSLogin os_login */ 12:
                    message.osLogin = OSLogin.internalBinaryRead(reader, reader.uint32(), options, message.osLogin);
                    break;
                case /* string my_platform */ 13:
                    message.myPlatform = reader.string();
                    break;
                case /* bytes hwid */ 14:
                    message.hwid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* bytes password = 2; */
        if (message.password.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.password);
        /* string my_id = 4; */
        if (message.myId !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.myId);
        /* string my_name = 5; */
        if (message.myName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.myName);
        /* hbb.OptionMessage option = 6; */
        if (message.option)
            OptionMessage.internalBinaryWrite(message.option, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransfer file_transfer = 7; */
        if (message.union.oneofKind === "fileTransfer")
            FileTransfer.internalBinaryWrite(message.union.fileTransfer, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PortForward port_forward = 8; */
        if (message.union.oneofKind === "portForward")
            PortForward.internalBinaryWrite(message.union.portForward, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* bool video_ack_required = 9; */
        if (message.videoAckRequired !== false)
            writer.tag(9, WireType.Varint).bool(message.videoAckRequired);
        /* uint64 session_id = 10; */
        if (message.sessionId !== 0n)
            writer.tag(10, WireType.Varint).uint64(message.sessionId);
        /* string version = 11; */
        if (message.version !== "")
            writer.tag(11, WireType.LengthDelimited).string(message.version);
        /* hbb.OSLogin os_login = 12; */
        if (message.osLogin)
            OSLogin.internalBinaryWrite(message.osLogin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* string my_platform = 13; */
        if (message.myPlatform !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.myPlatform);
        /* bytes hwid = 14; */
        if (message.hwid.length)
            writer.tag(14, WireType.LengthDelimited).bytes(message.hwid);
        /* hbb.ViewCamera view_camera = 15; */
        if (message.union.oneofKind === "viewCamera")
            ViewCamera.internalBinaryWrite(message.union.viewCamera, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Terminal terminal = 16; */
        if (message.union.oneofKind === "terminal")
            Terminal.internalBinaryWrite(message.union.terminal, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.LoginRequest
 */
export const LoginRequest = new LoginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Terminal$Type extends MessageType<Terminal> {
    constructor() {
        super("hbb.Terminal", [
            { no: 1, name: "service_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Terminal>): Terminal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.serviceId = "";
        if (value !== undefined)
            reflectionMergePartial<Terminal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Terminal): Terminal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string service_id */ 1:
                    message.serviceId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Terminal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string service_id = 1; */
        if (message.serviceId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.serviceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Terminal
 */
export const Terminal = new Terminal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Auth2FA$Type extends MessageType<Auth2FA> {
    constructor() {
        super("hbb.Auth2FA", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hwid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Auth2FA>): Auth2FA {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.hwid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Auth2FA>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Auth2FA): Auth2FA {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* bytes hwid */ 2:
                    message.hwid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Auth2FA, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* bytes hwid = 2; */
        if (message.hwid.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.hwid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Auth2FA
 */
export const Auth2FA = new Auth2FA$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChatMessage$Type extends MessageType<ChatMessage> {
    constructor() {
        super("hbb.ChatMessage", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ChatMessage>): ChatMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.text = "";
        if (value !== undefined)
            reflectionMergePartial<ChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChatMessage): ChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ChatMessage
 */
export const ChatMessage = new ChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Features$Type extends MessageType<Features> {
    constructor() {
        super("hbb.Features", [
            { no: 1, name: "privacy_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "terminal", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Features>): Features {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.privacyMode = false;
        message.terminal = false;
        if (value !== undefined)
            reflectionMergePartial<Features>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Features): Features {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool privacy_mode */ 1:
                    message.privacyMode = reader.bool();
                    break;
                case /* bool terminal */ 2:
                    message.terminal = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Features, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool privacy_mode = 1; */
        if (message.privacyMode !== false)
            writer.tag(1, WireType.Varint).bool(message.privacyMode);
        /* bool terminal = 2; */
        if (message.terminal !== false)
            writer.tag(2, WireType.Varint).bool(message.terminal);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Features
 */
export const Features = new Features$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CodecAbility$Type extends MessageType<CodecAbility> {
    constructor() {
        super("hbb.CodecAbility", [
            { no: 1, name: "vp8", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "vp9", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "av1", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "h264", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "h265", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CodecAbility>): CodecAbility {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.vp8 = false;
        message.vp9 = false;
        message.av1 = false;
        message.h264 = false;
        message.h265 = false;
        if (value !== undefined)
            reflectionMergePartial<CodecAbility>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CodecAbility): CodecAbility {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool vp8 */ 1:
                    message.vp8 = reader.bool();
                    break;
                case /* bool vp9 */ 2:
                    message.vp9 = reader.bool();
                    break;
                case /* bool av1 */ 3:
                    message.av1 = reader.bool();
                    break;
                case /* bool h264 */ 4:
                    message.h264 = reader.bool();
                    break;
                case /* bool h265 */ 5:
                    message.h265 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CodecAbility, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool vp8 = 1; */
        if (message.vp8 !== false)
            writer.tag(1, WireType.Varint).bool(message.vp8);
        /* bool vp9 = 2; */
        if (message.vp9 !== false)
            writer.tag(2, WireType.Varint).bool(message.vp9);
        /* bool av1 = 3; */
        if (message.av1 !== false)
            writer.tag(3, WireType.Varint).bool(message.av1);
        /* bool h264 = 4; */
        if (message.h264 !== false)
            writer.tag(4, WireType.Varint).bool(message.h264);
        /* bool h265 = 5; */
        if (message.h265 !== false)
            writer.tag(5, WireType.Varint).bool(message.h265);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CodecAbility
 */
export const CodecAbility = new CodecAbility$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportedEncoding$Type extends MessageType<SupportedEncoding> {
    constructor() {
        super("hbb.SupportedEncoding", [
            { no: 1, name: "h264", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "h265", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "vp8", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "av1", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "i444", kind: "message", T: () => CodecAbility }
        ]);
    }
    create(value?: PartialMessage<SupportedEncoding>): SupportedEncoding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.h264 = false;
        message.h265 = false;
        message.vp8 = false;
        message.av1 = false;
        if (value !== undefined)
            reflectionMergePartial<SupportedEncoding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupportedEncoding): SupportedEncoding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool h264 */ 1:
                    message.h264 = reader.bool();
                    break;
                case /* bool h265 */ 2:
                    message.h265 = reader.bool();
                    break;
                case /* bool vp8 */ 3:
                    message.vp8 = reader.bool();
                    break;
                case /* bool av1 */ 4:
                    message.av1 = reader.bool();
                    break;
                case /* hbb.CodecAbility i444 */ 5:
                    message.i444 = CodecAbility.internalBinaryRead(reader, reader.uint32(), options, message.i444);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupportedEncoding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool h264 = 1; */
        if (message.h264 !== false)
            writer.tag(1, WireType.Varint).bool(message.h264);
        /* bool h265 = 2; */
        if (message.h265 !== false)
            writer.tag(2, WireType.Varint).bool(message.h265);
        /* bool vp8 = 3; */
        if (message.vp8 !== false)
            writer.tag(3, WireType.Varint).bool(message.vp8);
        /* bool av1 = 4; */
        if (message.av1 !== false)
            writer.tag(4, WireType.Varint).bool(message.av1);
        /* hbb.CodecAbility i444 = 5; */
        if (message.i444)
            CodecAbility.internalBinaryWrite(message.i444, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SupportedEncoding
 */
export const SupportedEncoding = new SupportedEncoding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PeerInfo$Type extends MessageType<PeerInfo> {
    constructor() {
        super("hbb.PeerInfo", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hostname", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "platform", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "displays", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DisplayInfo },
            { no: 5, name: "current_display", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "sas_enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "features", kind: "message", T: () => Features },
            { no: 10, name: "encoding", kind: "message", T: () => SupportedEncoding },
            { no: 11, name: "resolutions", kind: "message", T: () => SupportedResolutions },
            { no: 12, name: "platform_additions", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "windows_sessions", kind: "message", T: () => WindowsSessions }
        ]);
    }
    create(value?: PartialMessage<PeerInfo>): PeerInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.hostname = "";
        message.platform = "";
        message.displays = [];
        message.currentDisplay = 0;
        message.sasEnabled = false;
        message.version = "";
        message.platformAdditions = "";
        if (value !== undefined)
            reflectionMergePartial<PeerInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PeerInfo): PeerInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string hostname */ 2:
                    message.hostname = reader.string();
                    break;
                case /* string platform */ 3:
                    message.platform = reader.string();
                    break;
                case /* repeated hbb.DisplayInfo displays */ 4:
                    message.displays.push(DisplayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 current_display */ 5:
                    message.currentDisplay = reader.int32();
                    break;
                case /* bool sas_enabled */ 6:
                    message.sasEnabled = reader.bool();
                    break;
                case /* string version */ 7:
                    message.version = reader.string();
                    break;
                case /* hbb.Features features */ 9:
                    message.features = Features.internalBinaryRead(reader, reader.uint32(), options, message.features);
                    break;
                case /* hbb.SupportedEncoding encoding */ 10:
                    message.encoding = SupportedEncoding.internalBinaryRead(reader, reader.uint32(), options, message.encoding);
                    break;
                case /* hbb.SupportedResolutions resolutions */ 11:
                    message.resolutions = SupportedResolutions.internalBinaryRead(reader, reader.uint32(), options, message.resolutions);
                    break;
                case /* string platform_additions */ 12:
                    message.platformAdditions = reader.string();
                    break;
                case /* hbb.WindowsSessions windows_sessions */ 13:
                    message.windowsSessions = WindowsSessions.internalBinaryRead(reader, reader.uint32(), options, message.windowsSessions);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PeerInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string hostname = 2; */
        if (message.hostname !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hostname);
        /* string platform = 3; */
        if (message.platform !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.platform);
        /* repeated hbb.DisplayInfo displays = 4; */
        for (let i = 0; i < message.displays.length; i++)
            DisplayInfo.internalBinaryWrite(message.displays[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* int32 current_display = 5; */
        if (message.currentDisplay !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentDisplay);
        /* bool sas_enabled = 6; */
        if (message.sasEnabled !== false)
            writer.tag(6, WireType.Varint).bool(message.sasEnabled);
        /* string version = 7; */
        if (message.version !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.version);
        /* hbb.Features features = 9; */
        if (message.features)
            Features.internalBinaryWrite(message.features, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SupportedEncoding encoding = 10; */
        if (message.encoding)
            SupportedEncoding.internalBinaryWrite(message.encoding, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SupportedResolutions resolutions = 11; */
        if (message.resolutions)
            SupportedResolutions.internalBinaryWrite(message.resolutions, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string platform_additions = 12; */
        if (message.platformAdditions !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.platformAdditions);
        /* hbb.WindowsSessions windows_sessions = 13; */
        if (message.windowsSessions)
            WindowsSessions.internalBinaryWrite(message.windowsSessions, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PeerInfo
 */
export const PeerInfo = new PeerInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsSession$Type extends MessageType<WindowsSession> {
    constructor() {
        super("hbb.WindowsSession", [
            { no: 1, name: "sid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WindowsSession>): WindowsSession {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sid = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WindowsSession>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsSession): WindowsSession {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sid */ 1:
                    message.sid = reader.uint32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsSession, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sid = 1; */
        if (message.sid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.WindowsSession
 */
export const WindowsSession = new WindowsSession$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoginResponse$Type extends MessageType<LoginResponse> {
    constructor() {
        super("hbb.LoginResponse", [
            { no: 1, name: "error", kind: "scalar", oneof: "union", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "peer_info", kind: "message", oneof: "union", T: () => PeerInfo },
            { no: 3, name: "enable_trusted_devices", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<LoginResponse>): LoginResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        message.enableTrustedDevices = false;
        if (value !== undefined)
            reflectionMergePartial<LoginResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoginResponse): LoginResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.union = {
                        oneofKind: "error",
                        error: reader.string()
                    };
                    break;
                case /* hbb.PeerInfo peer_info */ 2:
                    message.union = {
                        oneofKind: "peerInfo",
                        peerInfo: PeerInfo.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).peerInfo)
                    };
                    break;
                case /* bool enable_trusted_devices */ 3:
                    message.enableTrustedDevices = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.union.oneofKind === "error")
            writer.tag(1, WireType.LengthDelimited).string(message.union.error);
        /* hbb.PeerInfo peer_info = 2; */
        if (message.union.oneofKind === "peerInfo")
            PeerInfo.internalBinaryWrite(message.union.peerInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool enable_trusted_devices = 3; */
        if (message.enableTrustedDevices !== false)
            writer.tag(3, WireType.Varint).bool(message.enableTrustedDevices);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.LoginResponse
 */
export const LoginResponse = new LoginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TouchScaleUpdate$Type extends MessageType<TouchScaleUpdate> {
    constructor() {
        super("hbb.TouchScaleUpdate", [
            { no: 1, name: "scale", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TouchScaleUpdate>): TouchScaleUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.scale = 0;
        if (value !== undefined)
            reflectionMergePartial<TouchScaleUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TouchScaleUpdate): TouchScaleUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 scale */ 1:
                    message.scale = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TouchScaleUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 scale = 1; */
        if (message.scale !== 0)
            writer.tag(1, WireType.Varint).int32(message.scale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TouchScaleUpdate
 */
export const TouchScaleUpdate = new TouchScaleUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TouchPanStart$Type extends MessageType<TouchPanStart> {
    constructor() {
        super("hbb.TouchPanStart", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TouchPanStart>): TouchPanStart {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<TouchPanStart>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TouchPanStart): TouchPanStart {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TouchPanStart, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TouchPanStart
 */
export const TouchPanStart = new TouchPanStart$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TouchPanUpdate$Type extends MessageType<TouchPanUpdate> {
    constructor() {
        super("hbb.TouchPanUpdate", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TouchPanUpdate>): TouchPanUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<TouchPanUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TouchPanUpdate): TouchPanUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TouchPanUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TouchPanUpdate
 */
export const TouchPanUpdate = new TouchPanUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TouchPanEnd$Type extends MessageType<TouchPanEnd> {
    constructor() {
        super("hbb.TouchPanEnd", [
            { no: 1, name: "x", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TouchPanEnd>): TouchPanEnd {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<TouchPanEnd>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TouchPanEnd): TouchPanEnd {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 x */ 1:
                    message.x = reader.int32();
                    break;
                case /* int32 y */ 2:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TouchPanEnd, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).int32(message.x);
        /* int32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TouchPanEnd
 */
export const TouchPanEnd = new TouchPanEnd$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TouchEvent$Type extends MessageType<TouchEvent> {
    constructor() {
        super("hbb.TouchEvent", [
            { no: 1, name: "scale_update", kind: "message", oneof: "union", T: () => TouchScaleUpdate },
            { no: 2, name: "pan_start", kind: "message", oneof: "union", T: () => TouchPanStart },
            { no: 3, name: "pan_update", kind: "message", oneof: "union", T: () => TouchPanUpdate },
            { no: 4, name: "pan_end", kind: "message", oneof: "union", T: () => TouchPanEnd }
        ]);
    }
    create(value?: PartialMessage<TouchEvent>): TouchEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TouchEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TouchEvent): TouchEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.TouchScaleUpdate scale_update */ 1:
                    message.union = {
                        oneofKind: "scaleUpdate",
                        scaleUpdate: TouchScaleUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).scaleUpdate)
                    };
                    break;
                case /* hbb.TouchPanStart pan_start */ 2:
                    message.union = {
                        oneofKind: "panStart",
                        panStart: TouchPanStart.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).panStart)
                    };
                    break;
                case /* hbb.TouchPanUpdate pan_update */ 3:
                    message.union = {
                        oneofKind: "panUpdate",
                        panUpdate: TouchPanUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).panUpdate)
                    };
                    break;
                case /* hbb.TouchPanEnd pan_end */ 4:
                    message.union = {
                        oneofKind: "panEnd",
                        panEnd: TouchPanEnd.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).panEnd)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TouchEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.TouchScaleUpdate scale_update = 1; */
        if (message.union.oneofKind === "scaleUpdate")
            TouchScaleUpdate.internalBinaryWrite(message.union.scaleUpdate, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TouchPanStart pan_start = 2; */
        if (message.union.oneofKind === "panStart")
            TouchPanStart.internalBinaryWrite(message.union.panStart, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TouchPanUpdate pan_update = 3; */
        if (message.union.oneofKind === "panUpdate")
            TouchPanUpdate.internalBinaryWrite(message.union.panUpdate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TouchPanEnd pan_end = 4; */
        if (message.union.oneofKind === "panEnd")
            TouchPanEnd.internalBinaryWrite(message.union.panEnd, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TouchEvent
 */
export const TouchEvent = new TouchEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PointerDeviceEvent$Type extends MessageType<PointerDeviceEvent> {
    constructor() {
        super("hbb.PointerDeviceEvent", [
            { no: 1, name: "touch_event", kind: "message", oneof: "union", T: () => TouchEvent },
            { no: 2, name: "modifiers", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["hbb.ControlKey", ControlKey] }
        ]);
    }
    create(value?: PartialMessage<PointerDeviceEvent>): PointerDeviceEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        message.modifiers = [];
        if (value !== undefined)
            reflectionMergePartial<PointerDeviceEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PointerDeviceEvent): PointerDeviceEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.TouchEvent touch_event */ 1:
                    message.union = {
                        oneofKind: "touchEvent",
                        touchEvent: TouchEvent.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).touchEvent)
                    };
                    break;
                case /* repeated hbb.ControlKey modifiers */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modifiers.push(reader.int32());
                    else
                        message.modifiers.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PointerDeviceEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.TouchEvent touch_event = 1; */
        if (message.union.oneofKind === "touchEvent")
            TouchEvent.internalBinaryWrite(message.union.touchEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated hbb.ControlKey modifiers = 2; */
        if (message.modifiers.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.modifiers.length; i++)
                writer.int32(message.modifiers[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PointerDeviceEvent
 */
export const PointerDeviceEvent = new PointerDeviceEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MouseEvent$Type extends MessageType<MouseEvent> {
    constructor() {
        super("hbb.MouseEvent", [
            { no: 1, name: "mask", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "modifiers", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["hbb.ControlKey", ControlKey] }
        ]);
    }
    create(value?: PartialMessage<MouseEvent>): MouseEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mask = 0;
        message.x = 0;
        message.y = 0;
        message.modifiers = [];
        if (value !== undefined)
            reflectionMergePartial<MouseEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MouseEvent): MouseEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 mask */ 1:
                    message.mask = reader.int32();
                    break;
                case /* sint32 x */ 2:
                    message.x = reader.sint32();
                    break;
                case /* sint32 y */ 3:
                    message.y = reader.sint32();
                    break;
                case /* repeated hbb.ControlKey modifiers */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modifiers.push(reader.int32());
                    else
                        message.modifiers.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MouseEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 mask = 1; */
        if (message.mask !== 0)
            writer.tag(1, WireType.Varint).int32(message.mask);
        /* sint32 x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Varint).sint32(message.x);
        /* sint32 y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Varint).sint32(message.y);
        /* repeated hbb.ControlKey modifiers = 4; */
        if (message.modifiers.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.modifiers.length; i++)
                writer.int32(message.modifiers[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.MouseEvent
 */
export const MouseEvent = new MouseEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class KeyEvent$Type extends MessageType<KeyEvent> {
    constructor() {
        super("hbb.KeyEvent", [
            { no: 1, name: "down", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "press", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "control_key", kind: "enum", oneof: "union", T: () => ["hbb.ControlKey", ControlKey] },
            { no: 4, name: "chr", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "unicode", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "seq", kind: "scalar", oneof: "union", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "win2win_hotkey", kind: "scalar", jsonName: "win2winHotkey", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "modifiers", kind: "enum", repeat: 1 /*RepeatType.PACKED*/, T: () => ["hbb.ControlKey", ControlKey] },
            { no: 9, name: "mode", kind: "enum", T: () => ["hbb.KeyboardMode", KeyboardMode] }
        ]);
    }
    create(value?: PartialMessage<KeyEvent>): KeyEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.down = false;
        message.press = false;
        message.union = { oneofKind: undefined };
        message.modifiers = [];
        message.mode = 0;
        if (value !== undefined)
            reflectionMergePartial<KeyEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: KeyEvent): KeyEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool down */ 1:
                    message.down = reader.bool();
                    break;
                case /* bool press */ 2:
                    message.press = reader.bool();
                    break;
                case /* hbb.ControlKey control_key */ 3:
                    message.union = {
                        oneofKind: "controlKey",
                        controlKey: reader.int32()
                    };
                    break;
                case /* uint32 chr */ 4:
                    message.union = {
                        oneofKind: "chr",
                        chr: reader.uint32()
                    };
                    break;
                case /* uint32 unicode */ 5:
                    message.union = {
                        oneofKind: "unicode",
                        unicode: reader.uint32()
                    };
                    break;
                case /* string seq */ 6:
                    message.union = {
                        oneofKind: "seq",
                        seq: reader.string()
                    };
                    break;
                case /* uint32 win2win_hotkey */ 7:
                    message.union = {
                        oneofKind: "win2WinHotkey",
                        win2WinHotkey: reader.uint32()
                    };
                    break;
                case /* repeated hbb.ControlKey modifiers */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.modifiers.push(reader.int32());
                    else
                        message.modifiers.push(reader.int32());
                    break;
                case /* hbb.KeyboardMode mode */ 9:
                    message.mode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: KeyEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool down = 1; */
        if (message.down !== false)
            writer.tag(1, WireType.Varint).bool(message.down);
        /* bool press = 2; */
        if (message.press !== false)
            writer.tag(2, WireType.Varint).bool(message.press);
        /* hbb.ControlKey control_key = 3; */
        if (message.union.oneofKind === "controlKey")
            writer.tag(3, WireType.Varint).int32(message.union.controlKey);
        /* uint32 chr = 4; */
        if (message.union.oneofKind === "chr")
            writer.tag(4, WireType.Varint).uint32(message.union.chr);
        /* uint32 unicode = 5; */
        if (message.union.oneofKind === "unicode")
            writer.tag(5, WireType.Varint).uint32(message.union.unicode);
        /* string seq = 6; */
        if (message.union.oneofKind === "seq")
            writer.tag(6, WireType.LengthDelimited).string(message.union.seq);
        /* uint32 win2win_hotkey = 7; */
        if (message.union.oneofKind === "win2WinHotkey")
            writer.tag(7, WireType.Varint).uint32(message.union.win2WinHotkey);
        /* repeated hbb.ControlKey modifiers = 8; */
        if (message.modifiers.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.modifiers.length; i++)
                writer.int32(message.modifiers[i]);
            writer.join();
        }
        /* hbb.KeyboardMode mode = 9; */
        if (message.mode !== 0)
            writer.tag(9, WireType.Varint).int32(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.KeyEvent
 */
export const KeyEvent = new KeyEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CursorData$Type extends MessageType<CursorData> {
    constructor() {
        super("hbb.CursorData", [
            { no: 1, name: "id", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "hotx", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "hoty", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "colors", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CursorData>): CursorData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0n;
        message.hotx = 0;
        message.hoty = 0;
        message.width = 0;
        message.height = 0;
        message.colors = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CursorData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CursorData): CursorData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 id */ 1:
                    message.id = reader.uint64().toBigInt();
                    break;
                case /* sint32 hotx */ 2:
                    message.hotx = reader.sint32();
                    break;
                case /* sint32 hoty */ 3:
                    message.hoty = reader.sint32();
                    break;
                case /* int32 width */ 4:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 5:
                    message.height = reader.int32();
                    break;
                case /* bytes colors */ 6:
                    message.colors = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CursorData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 id = 1; */
        if (message.id !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.id);
        /* sint32 hotx = 2; */
        if (message.hotx !== 0)
            writer.tag(2, WireType.Varint).sint32(message.hotx);
        /* sint32 hoty = 3; */
        if (message.hoty !== 0)
            writer.tag(3, WireType.Varint).sint32(message.hoty);
        /* int32 width = 4; */
        if (message.width !== 0)
            writer.tag(4, WireType.Varint).int32(message.width);
        /* int32 height = 5; */
        if (message.height !== 0)
            writer.tag(5, WireType.Varint).int32(message.height);
        /* bytes colors = 6; */
        if (message.colors.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.colors);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CursorData
 */
export const CursorData = new CursorData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CursorPosition$Type extends MessageType<CursorPosition> {
    constructor() {
        super("hbb.CursorPosition", [
            { no: 1, name: "x", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 2, name: "y", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CursorPosition>): CursorPosition {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.x = 0;
        message.y = 0;
        if (value !== undefined)
            reflectionMergePartial<CursorPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CursorPosition): CursorPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* sint32 x */ 1:
                    message.x = reader.sint32();
                    break;
                case /* sint32 y */ 2:
                    message.y = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CursorPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* sint32 x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Varint).sint32(message.x);
        /* sint32 y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Varint).sint32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CursorPosition
 */
export const CursorPosition = new CursorPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Hash$Type extends MessageType<Hash> {
    constructor() {
        super("hbb.Hash", [
            { no: 1, name: "salt", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "challenge", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Hash>): Hash {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.salt = "";
        message.challenge = "";
        if (value !== undefined)
            reflectionMergePartial<Hash>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Hash): Hash {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string salt */ 1:
                    message.salt = reader.string();
                    break;
                case /* string challenge */ 2:
                    message.challenge = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Hash, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string salt = 1; */
        if (message.salt !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.salt);
        /* string challenge = 2; */
        if (message.challenge !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.challenge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Hash
 */
export const Hash = new Hash$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Clipboard$Type extends MessageType<Clipboard> {
    constructor() {
        super("hbb.Clipboard", [
            { no: 1, name: "compress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "format", kind: "enum", T: () => ["hbb.ClipboardFormat", ClipboardFormat] },
            { no: 6, name: "special_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Clipboard>): Clipboard {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.compress = false;
        message.content = new Uint8Array(0);
        message.width = 0;
        message.height = 0;
        message.format = 0;
        message.specialName = "";
        if (value !== undefined)
            reflectionMergePartial<Clipboard>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Clipboard): Clipboard {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool compress */ 1:
                    message.compress = reader.bool();
                    break;
                case /* bytes content */ 2:
                    message.content = reader.bytes();
                    break;
                case /* int32 width */ 3:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 4:
                    message.height = reader.int32();
                    break;
                case /* hbb.ClipboardFormat format */ 5:
                    message.format = reader.int32();
                    break;
                case /* string special_name */ 6:
                    message.specialName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Clipboard, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool compress = 1; */
        if (message.compress !== false)
            writer.tag(1, WireType.Varint).bool(message.compress);
        /* bytes content = 2; */
        if (message.content.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.content);
        /* int32 width = 3; */
        if (message.width !== 0)
            writer.tag(3, WireType.Varint).int32(message.width);
        /* int32 height = 4; */
        if (message.height !== 0)
            writer.tag(4, WireType.Varint).int32(message.height);
        /* hbb.ClipboardFormat format = 5; */
        if (message.format !== 0)
            writer.tag(5, WireType.Varint).int32(message.format);
        /* string special_name = 6; */
        if (message.specialName !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.specialName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Clipboard
 */
export const Clipboard = new Clipboard$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MultiClipboards$Type extends MessageType<MultiClipboards> {
    constructor() {
        super("hbb.MultiClipboards", [
            { no: 1, name: "clipboards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Clipboard }
        ]);
    }
    create(value?: PartialMessage<MultiClipboards>): MultiClipboards {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.clipboards = [];
        if (value !== undefined)
            reflectionMergePartial<MultiClipboards>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MultiClipboards): MultiClipboards {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.Clipboard clipboards */ 1:
                    message.clipboards.push(Clipboard.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MultiClipboards, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.Clipboard clipboards = 1; */
        for (let i = 0; i < message.clipboards.length; i++)
            Clipboard.internalBinaryWrite(message.clipboards[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.MultiClipboards
 */
export const MultiClipboards = new MultiClipboards$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileEntry$Type extends MessageType<FileEntry> {
    constructor() {
        super("hbb.FileEntry", [
            { no: 1, name: "entry_type", kind: "enum", T: () => ["hbb.FileType", FileType] },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "modified_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FileEntry>): FileEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entryType = 0;
        message.name = "";
        message.isHidden = false;
        message.size = 0n;
        message.modifiedTime = 0n;
        if (value !== undefined)
            reflectionMergePartial<FileEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileEntry): FileEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.FileType entry_type */ 1:
                    message.entryType = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* bool is_hidden */ 3:
                    message.isHidden = reader.bool();
                    break;
                case /* uint64 size */ 4:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint64 modified_time */ 5:
                    message.modifiedTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.FileType entry_type = 1; */
        if (message.entryType !== 0)
            writer.tag(1, WireType.Varint).int32(message.entryType);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* bool is_hidden = 3; */
        if (message.isHidden !== false)
            writer.tag(3, WireType.Varint).bool(message.isHidden);
        /* uint64 size = 4; */
        if (message.size !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.size);
        /* uint64 modified_time = 5; */
        if (message.modifiedTime !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.modifiedTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileEntry
 */
export const FileEntry = new FileEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileDirectory$Type extends MessageType<FileDirectory> {
    constructor() {
        super("hbb.FileDirectory", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileEntry }
        ]);
    }
    create(value?: PartialMessage<FileDirectory>): FileDirectory {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<FileDirectory>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileDirectory): FileDirectory {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* repeated hbb.FileEntry entries */ 3:
                    message.entries.push(FileEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileDirectory, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* repeated hbb.FileEntry entries = 3; */
        for (let i = 0; i < message.entries.length; i++)
            FileEntry.internalBinaryWrite(message.entries[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileDirectory
 */
export const FileDirectory = new FileDirectory$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadDir$Type extends MessageType<ReadDir> {
    constructor() {
        super("hbb.ReadDir", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReadDir>): ReadDir {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.includeHidden = false;
        if (value !== undefined)
            reflectionMergePartial<ReadDir>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadDir): ReadDir {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bool include_hidden */ 2:
                    message.includeHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadDir, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bool include_hidden = 2; */
        if (message.includeHidden !== false)
            writer.tag(2, WireType.Varint).bool(message.includeHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ReadDir
 */
export const ReadDir = new ReadDir$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadEmptyDirs$Type extends MessageType<ReadEmptyDirs> {
    constructor() {
        super("hbb.ReadEmptyDirs", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "include_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReadEmptyDirs>): ReadEmptyDirs {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.includeHidden = false;
        if (value !== undefined)
            reflectionMergePartial<ReadEmptyDirs>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadEmptyDirs): ReadEmptyDirs {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* bool include_hidden */ 2:
                    message.includeHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadEmptyDirs, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* bool include_hidden = 2; */
        if (message.includeHidden !== false)
            writer.tag(2, WireType.Varint).bool(message.includeHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ReadEmptyDirs
 */
export const ReadEmptyDirs = new ReadEmptyDirs$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadEmptyDirsResponse$Type extends MessageType<ReadEmptyDirsResponse> {
    constructor() {
        super("hbb.ReadEmptyDirsResponse", [
            { no: 1, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "empty_dirs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileDirectory }
        ]);
    }
    create(value?: PartialMessage<ReadEmptyDirsResponse>): ReadEmptyDirsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.path = "";
        message.emptyDirs = [];
        if (value !== undefined)
            reflectionMergePartial<ReadEmptyDirsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadEmptyDirsResponse): ReadEmptyDirsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string path */ 1:
                    message.path = reader.string();
                    break;
                case /* repeated hbb.FileDirectory empty_dirs */ 2:
                    message.emptyDirs.push(FileDirectory.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadEmptyDirsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string path = 1; */
        if (message.path !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.path);
        /* repeated hbb.FileDirectory empty_dirs = 2; */
        for (let i = 0; i < message.emptyDirs.length; i++)
            FileDirectory.internalBinaryWrite(message.emptyDirs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ReadEmptyDirsResponse
 */
export const ReadEmptyDirsResponse = new ReadEmptyDirsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadAllFiles$Type extends MessageType<ReadAllFiles> {
    constructor() {
        super("hbb.ReadAllFiles", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ReadAllFiles>): ReadAllFiles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.includeHidden = false;
        if (value !== undefined)
            reflectionMergePartial<ReadAllFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadAllFiles): ReadAllFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* bool include_hidden */ 3:
                    message.includeHidden = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadAllFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* bool include_hidden = 3; */
        if (message.includeHidden !== false)
            writer.tag(3, WireType.Varint).bool(message.includeHidden);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ReadAllFiles
 */
export const ReadAllFiles = new ReadAllFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileRename$Type extends MessageType<FileRename> {
    constructor() {
        super("hbb.FileRename", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "new_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileRename>): FileRename {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.newName = "";
        if (value !== undefined)
            reflectionMergePartial<FileRename>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileRename): FileRename {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* string new_name */ 3:
                    message.newName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileRename, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* string new_name = 3; */
        if (message.newName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.newName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileRename
 */
export const FileRename = new FileRename$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileAction$Type extends MessageType<FileAction> {
    constructor() {
        super("hbb.FileAction", [
            { no: 1, name: "read_dir", kind: "message", oneof: "union", T: () => ReadDir },
            { no: 2, name: "send", kind: "message", oneof: "union", T: () => FileTransferSendRequest },
            { no: 3, name: "receive", kind: "message", oneof: "union", T: () => FileTransferReceiveRequest },
            { no: 4, name: "create", kind: "message", oneof: "union", T: () => FileDirCreate },
            { no: 5, name: "remove_dir", kind: "message", oneof: "union", T: () => FileRemoveDir },
            { no: 6, name: "remove_file", kind: "message", oneof: "union", T: () => FileRemoveFile },
            { no: 7, name: "all_files", kind: "message", oneof: "union", T: () => ReadAllFiles },
            { no: 8, name: "cancel", kind: "message", oneof: "union", T: () => FileTransferCancel },
            { no: 9, name: "send_confirm", kind: "message", oneof: "union", T: () => FileTransferSendConfirmRequest },
            { no: 10, name: "rename", kind: "message", oneof: "union", T: () => FileRename },
            { no: 11, name: "read_empty_dirs", kind: "message", oneof: "union", T: () => ReadEmptyDirs }
        ]);
    }
    create(value?: PartialMessage<FileAction>): FileAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FileAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileAction): FileAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.ReadDir read_dir */ 1:
                    message.union = {
                        oneofKind: "readDir",
                        readDir: ReadDir.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).readDir)
                    };
                    break;
                case /* hbb.FileTransferSendRequest send */ 2:
                    message.union = {
                        oneofKind: "send",
                        send: FileTransferSendRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).send)
                    };
                    break;
                case /* hbb.FileTransferReceiveRequest receive */ 3:
                    message.union = {
                        oneofKind: "receive",
                        receive: FileTransferReceiveRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).receive)
                    };
                    break;
                case /* hbb.FileDirCreate create */ 4:
                    message.union = {
                        oneofKind: "create",
                        create: FileDirCreate.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).create)
                    };
                    break;
                case /* hbb.FileRemoveDir remove_dir */ 5:
                    message.union = {
                        oneofKind: "removeDir",
                        removeDir: FileRemoveDir.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).removeDir)
                    };
                    break;
                case /* hbb.FileRemoveFile remove_file */ 6:
                    message.union = {
                        oneofKind: "removeFile",
                        removeFile: FileRemoveFile.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).removeFile)
                    };
                    break;
                case /* hbb.ReadAllFiles all_files */ 7:
                    message.union = {
                        oneofKind: "allFiles",
                        allFiles: ReadAllFiles.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).allFiles)
                    };
                    break;
                case /* hbb.FileTransferCancel cancel */ 8:
                    message.union = {
                        oneofKind: "cancel",
                        cancel: FileTransferCancel.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).cancel)
                    };
                    break;
                case /* hbb.FileTransferSendConfirmRequest send_confirm */ 9:
                    message.union = {
                        oneofKind: "sendConfirm",
                        sendConfirm: FileTransferSendConfirmRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).sendConfirm)
                    };
                    break;
                case /* hbb.FileRename rename */ 10:
                    message.union = {
                        oneofKind: "rename",
                        rename: FileRename.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).rename)
                    };
                    break;
                case /* hbb.ReadEmptyDirs read_empty_dirs */ 11:
                    message.union = {
                        oneofKind: "readEmptyDirs",
                        readEmptyDirs: ReadEmptyDirs.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).readEmptyDirs)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.ReadDir read_dir = 1; */
        if (message.union.oneofKind === "readDir")
            ReadDir.internalBinaryWrite(message.union.readDir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferSendRequest send = 2; */
        if (message.union.oneofKind === "send")
            FileTransferSendRequest.internalBinaryWrite(message.union.send, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferReceiveRequest receive = 3; */
        if (message.union.oneofKind === "receive")
            FileTransferReceiveRequest.internalBinaryWrite(message.union.receive, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileDirCreate create = 4; */
        if (message.union.oneofKind === "create")
            FileDirCreate.internalBinaryWrite(message.union.create, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileRemoveDir remove_dir = 5; */
        if (message.union.oneofKind === "removeDir")
            FileRemoveDir.internalBinaryWrite(message.union.removeDir, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileRemoveFile remove_file = 6; */
        if (message.union.oneofKind === "removeFile")
            FileRemoveFile.internalBinaryWrite(message.union.removeFile, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ReadAllFiles all_files = 7; */
        if (message.union.oneofKind === "allFiles")
            ReadAllFiles.internalBinaryWrite(message.union.allFiles, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferCancel cancel = 8; */
        if (message.union.oneofKind === "cancel")
            FileTransferCancel.internalBinaryWrite(message.union.cancel, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferSendConfirmRequest send_confirm = 9; */
        if (message.union.oneofKind === "sendConfirm")
            FileTransferSendConfirmRequest.internalBinaryWrite(message.union.sendConfirm, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileRename rename = 10; */
        if (message.union.oneofKind === "rename")
            FileRename.internalBinaryWrite(message.union.rename, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ReadEmptyDirs read_empty_dirs = 11; */
        if (message.union.oneofKind === "readEmptyDirs")
            ReadEmptyDirs.internalBinaryWrite(message.union.readEmptyDirs, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileAction
 */
export const FileAction = new FileAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferCancel$Type extends MessageType<FileTransferCancel> {
    constructor() {
        super("hbb.FileTransferCancel", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferCancel>): FileTransferCancel {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferCancel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferCancel): FileTransferCancel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferCancel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferCancel
 */
export const FileTransferCancel = new FileTransferCancel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileResponse$Type extends MessageType<FileResponse> {
    constructor() {
        super("hbb.FileResponse", [
            { no: 1, name: "dir", kind: "message", oneof: "union", T: () => FileDirectory },
            { no: 2, name: "block", kind: "message", oneof: "union", T: () => FileTransferBlock },
            { no: 3, name: "error", kind: "message", oneof: "union", T: () => FileTransferError },
            { no: 4, name: "done", kind: "message", oneof: "union", T: () => FileTransferDone },
            { no: 5, name: "digest", kind: "message", oneof: "union", T: () => FileTransferDigest },
            { no: 6, name: "empty_dirs", kind: "message", oneof: "union", T: () => ReadEmptyDirsResponse }
        ]);
    }
    create(value?: PartialMessage<FileResponse>): FileResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileResponse): FileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.FileDirectory dir */ 1:
                    message.union = {
                        oneofKind: "dir",
                        dir: FileDirectory.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).dir)
                    };
                    break;
                case /* hbb.FileTransferBlock block */ 2:
                    message.union = {
                        oneofKind: "block",
                        block: FileTransferBlock.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).block)
                    };
                    break;
                case /* hbb.FileTransferError error */ 3:
                    message.union = {
                        oneofKind: "error",
                        error: FileTransferError.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).error)
                    };
                    break;
                case /* hbb.FileTransferDone done */ 4:
                    message.union = {
                        oneofKind: "done",
                        done: FileTransferDone.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).done)
                    };
                    break;
                case /* hbb.FileTransferDigest digest */ 5:
                    message.union = {
                        oneofKind: "digest",
                        digest: FileTransferDigest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).digest)
                    };
                    break;
                case /* hbb.ReadEmptyDirsResponse empty_dirs */ 6:
                    message.union = {
                        oneofKind: "emptyDirs",
                        emptyDirs: ReadEmptyDirsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).emptyDirs)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.FileDirectory dir = 1; */
        if (message.union.oneofKind === "dir")
            FileDirectory.internalBinaryWrite(message.union.dir, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferBlock block = 2; */
        if (message.union.oneofKind === "block")
            FileTransferBlock.internalBinaryWrite(message.union.block, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferError error = 3; */
        if (message.union.oneofKind === "error")
            FileTransferError.internalBinaryWrite(message.union.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferDone done = 4; */
        if (message.union.oneofKind === "done")
            FileTransferDone.internalBinaryWrite(message.union.done, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileTransferDigest digest = 5; */
        if (message.union.oneofKind === "digest")
            FileTransferDigest.internalBinaryWrite(message.union.digest, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ReadEmptyDirsResponse empty_dirs = 6; */
        if (message.union.oneofKind === "emptyDirs")
            ReadEmptyDirsResponse.internalBinaryWrite(message.union.emptyDirs, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileResponse
 */
export const FileResponse = new FileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferDigest$Type extends MessageType<FileTransferDigest> {
    constructor() {
        super("hbb.FileTransferDigest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "last_modified", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "file_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "is_upload", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "is_identical", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "transferred_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "is_resume", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferDigest>): FileTransferDigest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fileNum = 0;
        message.lastModified = 0n;
        message.fileSize = 0n;
        message.isUpload = false;
        message.isIdentical = false;
        message.transferredSize = 0n;
        message.isResume = false;
        if (value !== undefined)
            reflectionMergePartial<FileTransferDigest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferDigest): FileTransferDigest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* sint32 file_num */ 2:
                    message.fileNum = reader.sint32();
                    break;
                case /* uint64 last_modified */ 3:
                    message.lastModified = reader.uint64().toBigInt();
                    break;
                case /* uint64 file_size */ 4:
                    message.fileSize = reader.uint64().toBigInt();
                    break;
                case /* bool is_upload */ 5:
                    message.isUpload = reader.bool();
                    break;
                case /* bool is_identical */ 6:
                    message.isIdentical = reader.bool();
                    break;
                case /* uint64 transferred_size */ 7:
                    message.transferredSize = reader.uint64().toBigInt();
                    break;
                case /* bool is_resume */ 8:
                    message.isResume = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferDigest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* sint32 file_num = 2; */
        if (message.fileNum !== 0)
            writer.tag(2, WireType.Varint).sint32(message.fileNum);
        /* uint64 last_modified = 3; */
        if (message.lastModified !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.lastModified);
        /* uint64 file_size = 4; */
        if (message.fileSize !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.fileSize);
        /* bool is_upload = 5; */
        if (message.isUpload !== false)
            writer.tag(5, WireType.Varint).bool(message.isUpload);
        /* bool is_identical = 6; */
        if (message.isIdentical !== false)
            writer.tag(6, WireType.Varint).bool(message.isIdentical);
        /* uint64 transferred_size = 7; */
        if (message.transferredSize !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.transferredSize);
        /* bool is_resume = 8; */
        if (message.isResume !== false)
            writer.tag(8, WireType.Varint).bool(message.isResume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferDigest
 */
export const FileTransferDigest = new FileTransferDigest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferBlock$Type extends MessageType<FileTransferBlock> {
    constructor() {
        super("hbb.FileTransferBlock", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 4, name: "compressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "blk_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferBlock>): FileTransferBlock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fileNum = 0;
        message.data = new Uint8Array(0);
        message.compressed = false;
        message.blkId = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferBlock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferBlock): FileTransferBlock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* sint32 file_num */ 2:
                    message.fileNum = reader.sint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                case /* bool compressed */ 4:
                    message.compressed = reader.bool();
                    break;
                case /* uint32 blk_id */ 5:
                    message.blkId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferBlock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* sint32 file_num = 2; */
        if (message.fileNum !== 0)
            writer.tag(2, WireType.Varint).sint32(message.fileNum);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        /* bool compressed = 4; */
        if (message.compressed !== false)
            writer.tag(4, WireType.Varint).bool(message.compressed);
        /* uint32 blk_id = 5; */
        if (message.blkId !== 0)
            writer.tag(5, WireType.Varint).uint32(message.blkId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferBlock
 */
export const FileTransferBlock = new FileTransferBlock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferError$Type extends MessageType<FileTransferError> {
    constructor() {
        super("hbb.FileTransferError", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferError>): FileTransferError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.error = "";
        message.fileNum = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferError): FileTransferError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string error */ 2:
                    message.error = reader.string();
                    break;
                case /* sint32 file_num */ 3:
                    message.fileNum = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string error = 2; */
        if (message.error !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.error);
        /* sint32 file_num = 3; */
        if (message.fileNum !== 0)
            writer.tag(3, WireType.Varint).sint32(message.fileNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferError
 */
export const FileTransferError = new FileTransferError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferSendRequest$Type extends MessageType<FileTransferSendRequest> {
    constructor() {
        super("hbb.FileTransferSendRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "include_hidden", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "file_num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "file_type", kind: "enum", T: () => ["hbb.FileTransferSendRequest.FileType", FileTransferSendRequest_FileType] }
        ]);
    }
    create(value?: PartialMessage<FileTransferSendRequest>): FileTransferSendRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.includeHidden = false;
        message.fileNum = 0;
        message.fileType = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferSendRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferSendRequest): FileTransferSendRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* bool include_hidden */ 3:
                    message.includeHidden = reader.bool();
                    break;
                case /* int32 file_num */ 4:
                    message.fileNum = reader.int32();
                    break;
                case /* hbb.FileTransferSendRequest.FileType file_type */ 5:
                    message.fileType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferSendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* bool include_hidden = 3; */
        if (message.includeHidden !== false)
            writer.tag(3, WireType.Varint).bool(message.includeHidden);
        /* int32 file_num = 4; */
        if (message.fileNum !== 0)
            writer.tag(4, WireType.Varint).int32(message.fileNum);
        /* hbb.FileTransferSendRequest.FileType file_type = 5; */
        if (message.fileType !== 0)
            writer.tag(5, WireType.Varint).int32(message.fileType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferSendRequest
 */
export const FileTransferSendRequest = new FileTransferSendRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferSendConfirmRequest$Type extends MessageType<FileTransferSendConfirmRequest> {
    constructor() {
        super("hbb.FileTransferSendConfirmRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "skip", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "offset_blk", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferSendConfirmRequest>): FileTransferSendConfirmRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fileNum = 0;
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<FileTransferSendConfirmRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferSendConfirmRequest): FileTransferSendConfirmRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* sint32 file_num */ 2:
                    message.fileNum = reader.sint32();
                    break;
                case /* bool skip */ 3:
                    message.union = {
                        oneofKind: "skip",
                        skip: reader.bool()
                    };
                    break;
                case /* uint32 offset_blk */ 4:
                    message.union = {
                        oneofKind: "offsetBlk",
                        offsetBlk: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferSendConfirmRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* sint32 file_num = 2; */
        if (message.fileNum !== 0)
            writer.tag(2, WireType.Varint).sint32(message.fileNum);
        /* bool skip = 3; */
        if (message.union.oneofKind === "skip")
            writer.tag(3, WireType.Varint).bool(message.union.skip);
        /* uint32 offset_blk = 4; */
        if (message.union.oneofKind === "offsetBlk")
            writer.tag(4, WireType.Varint).uint32(message.union.offsetBlk);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferSendConfirmRequest
 */
export const FileTransferSendConfirmRequest = new FileTransferSendConfirmRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferDone$Type extends MessageType<FileTransferDone> {
    constructor() {
        super("hbb.FileTransferDone", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferDone>): FileTransferDone {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.fileNum = 0;
        if (value !== undefined)
            reflectionMergePartial<FileTransferDone>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferDone): FileTransferDone {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* sint32 file_num */ 2:
                    message.fileNum = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferDone, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* sint32 file_num = 2; */
        if (message.fileNum !== 0)
            writer.tag(2, WireType.Varint).sint32(message.fileNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferDone
 */
export const FileTransferDone = new FileTransferDone$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileTransferReceiveRequest$Type extends MessageType<FileTransferReceiveRequest> {
    constructor() {
        super("hbb.FileTransferReceiveRequest", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FileEntry },
            { no: 4, name: "file_num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "total_size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FileTransferReceiveRequest>): FileTransferReceiveRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.files = [];
        message.fileNum = 0;
        message.totalSize = 0n;
        if (value !== undefined)
            reflectionMergePartial<FileTransferReceiveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileTransferReceiveRequest): FileTransferReceiveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* repeated hbb.FileEntry files */ 3:
                    message.files.push(FileEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 file_num */ 4:
                    message.fileNum = reader.int32();
                    break;
                case /* uint64 total_size */ 5:
                    message.totalSize = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileTransferReceiveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* repeated hbb.FileEntry files = 3; */
        for (let i = 0; i < message.files.length; i++)
            FileEntry.internalBinaryWrite(message.files[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int32 file_num = 4; */
        if (message.fileNum !== 0)
            writer.tag(4, WireType.Varint).int32(message.fileNum);
        /* uint64 total_size = 5; */
        if (message.totalSize !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.totalSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileTransferReceiveRequest
 */
export const FileTransferReceiveRequest = new FileTransferReceiveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileRemoveDir$Type extends MessageType<FileRemoveDir> {
    constructor() {
        super("hbb.FileRemoveDir", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "recursive", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FileRemoveDir>): FileRemoveDir {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.recursive = false;
        if (value !== undefined)
            reflectionMergePartial<FileRemoveDir>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileRemoveDir): FileRemoveDir {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* bool recursive */ 3:
                    message.recursive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileRemoveDir, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* bool recursive = 3; */
        if (message.recursive !== false)
            writer.tag(3, WireType.Varint).bool(message.recursive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileRemoveDir
 */
export const FileRemoveDir = new FileRemoveDir$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileRemoveFile$Type extends MessageType<FileRemoveFile> {
    constructor() {
        super("hbb.FileRemoveFile", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "file_num", kind: "scalar", T: 17 /*ScalarType.SINT32*/ }
        ]);
    }
    create(value?: PartialMessage<FileRemoveFile>): FileRemoveFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        message.fileNum = 0;
        if (value !== undefined)
            reflectionMergePartial<FileRemoveFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileRemoveFile): FileRemoveFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                case /* sint32 file_num */ 3:
                    message.fileNum = reader.sint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileRemoveFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        /* sint32 file_num = 3; */
        if (message.fileNum !== 0)
            writer.tag(3, WireType.Varint).sint32(message.fileNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileRemoveFile
 */
export const FileRemoveFile = new FileRemoveFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FileDirCreate$Type extends MessageType<FileDirCreate> {
    constructor() {
        super("hbb.FileDirCreate", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "path", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FileDirCreate>): FileDirCreate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.path = "";
        if (value !== undefined)
            reflectionMergePartial<FileDirCreate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FileDirCreate): FileDirCreate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string path */ 2:
                    message.path = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FileDirCreate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string path = 2; */
        if (message.path !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.path);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.FileDirCreate
 */
export const FileDirCreate = new FileDirCreate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrMonitorReady$Type extends MessageType<CliprdrMonitorReady> {
    constructor() {
        super("hbb.CliprdrMonitorReady", []);
    }
    create(value?: PartialMessage<CliprdrMonitorReady>): CliprdrMonitorReady {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CliprdrMonitorReady>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrMonitorReady): CliprdrMonitorReady {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrMonitorReady, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrMonitorReady
 */
export const CliprdrMonitorReady = new CliprdrMonitorReady$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrFormat$Type extends MessageType<CliprdrFormat> {
    constructor() {
        super("hbb.CliprdrFormat", [
            { no: 2, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "format", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrFormat>): CliprdrFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.format = "";
        if (value !== undefined)
            reflectionMergePartial<CliprdrFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrFormat): CliprdrFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* string format */ 3:
                    message.format = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 2; */
        if (message.id !== 0)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* string format = 3; */
        if (message.format !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.format);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrFormat
 */
export const CliprdrFormat = new CliprdrFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrServerFormatList$Type extends MessageType<CliprdrServerFormatList> {
    constructor() {
        super("hbb.CliprdrServerFormatList", [
            { no: 2, name: "formats", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CliprdrFormat }
        ]);
    }
    create(value?: PartialMessage<CliprdrServerFormatList>): CliprdrServerFormatList {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.formats = [];
        if (value !== undefined)
            reflectionMergePartial<CliprdrServerFormatList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrServerFormatList): CliprdrServerFormatList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.CliprdrFormat formats */ 2:
                    message.formats.push(CliprdrFormat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrServerFormatList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.CliprdrFormat formats = 2; */
        for (let i = 0; i < message.formats.length; i++)
            CliprdrFormat.internalBinaryWrite(message.formats[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrServerFormatList
 */
export const CliprdrServerFormatList = new CliprdrServerFormatList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrServerFormatListResponse$Type extends MessageType<CliprdrServerFormatListResponse> {
    constructor() {
        super("hbb.CliprdrServerFormatListResponse", [
            { no: 2, name: "msg_flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrServerFormatListResponse>): CliprdrServerFormatListResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msgFlags = 0;
        if (value !== undefined)
            reflectionMergePartial<CliprdrServerFormatListResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrServerFormatListResponse): CliprdrServerFormatListResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 msg_flags */ 2:
                    message.msgFlags = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrServerFormatListResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 msg_flags = 2; */
        if (message.msgFlags !== 0)
            writer.tag(2, WireType.Varint).int32(message.msgFlags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrServerFormatListResponse
 */
export const CliprdrServerFormatListResponse = new CliprdrServerFormatListResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrServerFormatDataRequest$Type extends MessageType<CliprdrServerFormatDataRequest> {
    constructor() {
        super("hbb.CliprdrServerFormatDataRequest", [
            { no: 2, name: "requested_format_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrServerFormatDataRequest>): CliprdrServerFormatDataRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.requestedFormatId = 0;
        if (value !== undefined)
            reflectionMergePartial<CliprdrServerFormatDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrServerFormatDataRequest): CliprdrServerFormatDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 requested_format_id */ 2:
                    message.requestedFormatId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrServerFormatDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 requested_format_id = 2; */
        if (message.requestedFormatId !== 0)
            writer.tag(2, WireType.Varint).int32(message.requestedFormatId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrServerFormatDataRequest
 */
export const CliprdrServerFormatDataRequest = new CliprdrServerFormatDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrServerFormatDataResponse$Type extends MessageType<CliprdrServerFormatDataResponse> {
    constructor() {
        super("hbb.CliprdrServerFormatDataResponse", [
            { no: 2, name: "msg_flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "format_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrServerFormatDataResponse>): CliprdrServerFormatDataResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msgFlags = 0;
        message.formatData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CliprdrServerFormatDataResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrServerFormatDataResponse): CliprdrServerFormatDataResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 msg_flags */ 2:
                    message.msgFlags = reader.int32();
                    break;
                case /* bytes format_data */ 3:
                    message.formatData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrServerFormatDataResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 msg_flags = 2; */
        if (message.msgFlags !== 0)
            writer.tag(2, WireType.Varint).int32(message.msgFlags);
        /* bytes format_data = 3; */
        if (message.formatData.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.formatData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrServerFormatDataResponse
 */
export const CliprdrServerFormatDataResponse = new CliprdrServerFormatDataResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrFileContentsRequest$Type extends MessageType<CliprdrFileContentsRequest> {
    constructor() {
        super("hbb.CliprdrFileContentsRequest", [
            { no: 2, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "list_index", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "dw_flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "n_position_low", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "n_position_high", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "cb_requested", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "have_clip_data_id", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "clip_data_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrFileContentsRequest>): CliprdrFileContentsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.streamId = 0;
        message.listIndex = 0;
        message.dwFlags = 0;
        message.nPositionLow = 0;
        message.nPositionHigh = 0;
        message.cbRequested = 0;
        message.haveClipDataId = false;
        message.clipDataId = 0;
        if (value !== undefined)
            reflectionMergePartial<CliprdrFileContentsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrFileContentsRequest): CliprdrFileContentsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stream_id */ 2:
                    message.streamId = reader.int32();
                    break;
                case /* int32 list_index */ 3:
                    message.listIndex = reader.int32();
                    break;
                case /* int32 dw_flags */ 4:
                    message.dwFlags = reader.int32();
                    break;
                case /* int32 n_position_low */ 5:
                    message.nPositionLow = reader.int32();
                    break;
                case /* int32 n_position_high */ 6:
                    message.nPositionHigh = reader.int32();
                    break;
                case /* int32 cb_requested */ 7:
                    message.cbRequested = reader.int32();
                    break;
                case /* bool have_clip_data_id */ 8:
                    message.haveClipDataId = reader.bool();
                    break;
                case /* int32 clip_data_id */ 9:
                    message.clipDataId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrFileContentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stream_id = 2; */
        if (message.streamId !== 0)
            writer.tag(2, WireType.Varint).int32(message.streamId);
        /* int32 list_index = 3; */
        if (message.listIndex !== 0)
            writer.tag(3, WireType.Varint).int32(message.listIndex);
        /* int32 dw_flags = 4; */
        if (message.dwFlags !== 0)
            writer.tag(4, WireType.Varint).int32(message.dwFlags);
        /* int32 n_position_low = 5; */
        if (message.nPositionLow !== 0)
            writer.tag(5, WireType.Varint).int32(message.nPositionLow);
        /* int32 n_position_high = 6; */
        if (message.nPositionHigh !== 0)
            writer.tag(6, WireType.Varint).int32(message.nPositionHigh);
        /* int32 cb_requested = 7; */
        if (message.cbRequested !== 0)
            writer.tag(7, WireType.Varint).int32(message.cbRequested);
        /* bool have_clip_data_id = 8; */
        if (message.haveClipDataId !== false)
            writer.tag(8, WireType.Varint).bool(message.haveClipDataId);
        /* int32 clip_data_id = 9; */
        if (message.clipDataId !== 0)
            writer.tag(9, WireType.Varint).int32(message.clipDataId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrFileContentsRequest
 */
export const CliprdrFileContentsRequest = new CliprdrFileContentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrFileContentsResponse$Type extends MessageType<CliprdrFileContentsResponse> {
    constructor() {
        super("hbb.CliprdrFileContentsResponse", [
            { no: 3, name: "msg_flags", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "stream_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "requested_data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrFileContentsResponse>): CliprdrFileContentsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msgFlags = 0;
        message.streamId = 0;
        message.requestedData = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<CliprdrFileContentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrFileContentsResponse): CliprdrFileContentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 msg_flags */ 3:
                    message.msgFlags = reader.int32();
                    break;
                case /* int32 stream_id */ 4:
                    message.streamId = reader.int32();
                    break;
                case /* bytes requested_data */ 5:
                    message.requestedData = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrFileContentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 msg_flags = 3; */
        if (message.msgFlags !== 0)
            writer.tag(3, WireType.Varint).int32(message.msgFlags);
        /* int32 stream_id = 4; */
        if (message.streamId !== 0)
            writer.tag(4, WireType.Varint).int32(message.streamId);
        /* bytes requested_data = 5; */
        if (message.requestedData.length)
            writer.tag(5, WireType.LengthDelimited).bytes(message.requestedData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrFileContentsResponse
 */
export const CliprdrFileContentsResponse = new CliprdrFileContentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrTryEmpty$Type extends MessageType<CliprdrTryEmpty> {
    constructor() {
        super("hbb.CliprdrTryEmpty", []);
    }
    create(value?: PartialMessage<CliprdrTryEmpty>): CliprdrTryEmpty {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CliprdrTryEmpty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrTryEmpty): CliprdrTryEmpty {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrTryEmpty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrTryEmpty
 */
export const CliprdrTryEmpty = new CliprdrTryEmpty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrFile$Type extends MessageType<CliprdrFile> {
    constructor() {
        super("hbb.CliprdrFile", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<CliprdrFile>): CliprdrFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.size = 0n;
        if (value !== undefined)
            reflectionMergePartial<CliprdrFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrFile): CliprdrFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* uint64 size */ 2:
                    message.size = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* uint64 size = 2; */
        if (message.size !== 0n)
            writer.tag(2, WireType.Varint).uint64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrFile
 */
export const CliprdrFile = new CliprdrFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CliprdrFiles$Type extends MessageType<CliprdrFiles> {
    constructor() {
        super("hbb.CliprdrFiles", [
            { no: 1, name: "files", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CliprdrFile }
        ]);
    }
    create(value?: PartialMessage<CliprdrFiles>): CliprdrFiles {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.files = [];
        if (value !== undefined)
            reflectionMergePartial<CliprdrFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CliprdrFiles): CliprdrFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.CliprdrFile files */ 1:
                    message.files.push(CliprdrFile.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CliprdrFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.CliprdrFile files = 1; */
        for (let i = 0; i < message.files.length; i++)
            CliprdrFile.internalBinaryWrite(message.files[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CliprdrFiles
 */
export const CliprdrFiles = new CliprdrFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Cliprdr$Type extends MessageType<Cliprdr> {
    constructor() {
        super("hbb.Cliprdr", [
            { no: 1, name: "ready", kind: "message", oneof: "union", T: () => CliprdrMonitorReady },
            { no: 2, name: "format_list", kind: "message", oneof: "union", T: () => CliprdrServerFormatList },
            { no: 3, name: "format_list_response", kind: "message", oneof: "union", T: () => CliprdrServerFormatListResponse },
            { no: 4, name: "format_data_request", kind: "message", oneof: "union", T: () => CliprdrServerFormatDataRequest },
            { no: 5, name: "format_data_response", kind: "message", oneof: "union", T: () => CliprdrServerFormatDataResponse },
            { no: 6, name: "file_contents_request", kind: "message", oneof: "union", T: () => CliprdrFileContentsRequest },
            { no: 7, name: "file_contents_response", kind: "message", oneof: "union", T: () => CliprdrFileContentsResponse },
            { no: 8, name: "try_empty", kind: "message", oneof: "union", T: () => CliprdrTryEmpty },
            { no: 9, name: "files", kind: "message", oneof: "union", T: () => CliprdrFiles }
        ]);
    }
    create(value?: PartialMessage<Cliprdr>): Cliprdr {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Cliprdr>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Cliprdr): Cliprdr {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.CliprdrMonitorReady ready */ 1:
                    message.union = {
                        oneofKind: "ready",
                        ready: CliprdrMonitorReady.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).ready)
                    };
                    break;
                case /* hbb.CliprdrServerFormatList format_list */ 2:
                    message.union = {
                        oneofKind: "formatList",
                        formatList: CliprdrServerFormatList.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).formatList)
                    };
                    break;
                case /* hbb.CliprdrServerFormatListResponse format_list_response */ 3:
                    message.union = {
                        oneofKind: "formatListResponse",
                        formatListResponse: CliprdrServerFormatListResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).formatListResponse)
                    };
                    break;
                case /* hbb.CliprdrServerFormatDataRequest format_data_request */ 4:
                    message.union = {
                        oneofKind: "formatDataRequest",
                        formatDataRequest: CliprdrServerFormatDataRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).formatDataRequest)
                    };
                    break;
                case /* hbb.CliprdrServerFormatDataResponse format_data_response */ 5:
                    message.union = {
                        oneofKind: "formatDataResponse",
                        formatDataResponse: CliprdrServerFormatDataResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).formatDataResponse)
                    };
                    break;
                case /* hbb.CliprdrFileContentsRequest file_contents_request */ 6:
                    message.union = {
                        oneofKind: "fileContentsRequest",
                        fileContentsRequest: CliprdrFileContentsRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fileContentsRequest)
                    };
                    break;
                case /* hbb.CliprdrFileContentsResponse file_contents_response */ 7:
                    message.union = {
                        oneofKind: "fileContentsResponse",
                        fileContentsResponse: CliprdrFileContentsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fileContentsResponse)
                    };
                    break;
                case /* hbb.CliprdrTryEmpty try_empty */ 8:
                    message.union = {
                        oneofKind: "tryEmpty",
                        tryEmpty: CliprdrTryEmpty.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).tryEmpty)
                    };
                    break;
                case /* hbb.CliprdrFiles files */ 9:
                    message.union = {
                        oneofKind: "files",
                        files: CliprdrFiles.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).files)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Cliprdr, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.CliprdrMonitorReady ready = 1; */
        if (message.union.oneofKind === "ready")
            CliprdrMonitorReady.internalBinaryWrite(message.union.ready, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrServerFormatList format_list = 2; */
        if (message.union.oneofKind === "formatList")
            CliprdrServerFormatList.internalBinaryWrite(message.union.formatList, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrServerFormatListResponse format_list_response = 3; */
        if (message.union.oneofKind === "formatListResponse")
            CliprdrServerFormatListResponse.internalBinaryWrite(message.union.formatListResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrServerFormatDataRequest format_data_request = 4; */
        if (message.union.oneofKind === "formatDataRequest")
            CliprdrServerFormatDataRequest.internalBinaryWrite(message.union.formatDataRequest, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrServerFormatDataResponse format_data_response = 5; */
        if (message.union.oneofKind === "formatDataResponse")
            CliprdrServerFormatDataResponse.internalBinaryWrite(message.union.formatDataResponse, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrFileContentsRequest file_contents_request = 6; */
        if (message.union.oneofKind === "fileContentsRequest")
            CliprdrFileContentsRequest.internalBinaryWrite(message.union.fileContentsRequest, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrFileContentsResponse file_contents_response = 7; */
        if (message.union.oneofKind === "fileContentsResponse")
            CliprdrFileContentsResponse.internalBinaryWrite(message.union.fileContentsResponse, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrTryEmpty try_empty = 8; */
        if (message.union.oneofKind === "tryEmpty")
            CliprdrTryEmpty.internalBinaryWrite(message.union.tryEmpty, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CliprdrFiles files = 9; */
        if (message.union.oneofKind === "files")
            CliprdrFiles.internalBinaryWrite(message.union.files, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Cliprdr
 */
export const Cliprdr = new Cliprdr$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Resolution$Type extends MessageType<Resolution> {
    constructor() {
        super("hbb.Resolution", [
            { no: 1, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Resolution>): Resolution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.width = 0;
        message.height = 0;
        if (value !== undefined)
            reflectionMergePartial<Resolution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Resolution): Resolution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 width */ 1:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 2:
                    message.height = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Resolution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 width = 1; */
        if (message.width !== 0)
            writer.tag(1, WireType.Varint).int32(message.width);
        /* int32 height = 2; */
        if (message.height !== 0)
            writer.tag(2, WireType.Varint).int32(message.height);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Resolution
 */
export const Resolution = new Resolution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DisplayResolution$Type extends MessageType<DisplayResolution> {
    constructor() {
        super("hbb.DisplayResolution", [
            { no: 1, name: "display", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "resolution", kind: "message", T: () => Resolution }
        ]);
    }
    create(value?: PartialMessage<DisplayResolution>): DisplayResolution {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.display = 0;
        if (value !== undefined)
            reflectionMergePartial<DisplayResolution>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DisplayResolution): DisplayResolution {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 display */ 1:
                    message.display = reader.int32();
                    break;
                case /* hbb.Resolution resolution */ 2:
                    message.resolution = Resolution.internalBinaryRead(reader, reader.uint32(), options, message.resolution);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DisplayResolution, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 display = 1; */
        if (message.display !== 0)
            writer.tag(1, WireType.Varint).int32(message.display);
        /* hbb.Resolution resolution = 2; */
        if (message.resolution)
            Resolution.internalBinaryWrite(message.resolution, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.DisplayResolution
 */
export const DisplayResolution = new DisplayResolution$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportedResolutions$Type extends MessageType<SupportedResolutions> {
    constructor() {
        super("hbb.SupportedResolutions", [
            { no: 1, name: "resolutions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Resolution }
        ]);
    }
    create(value?: PartialMessage<SupportedResolutions>): SupportedResolutions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.resolutions = [];
        if (value !== undefined)
            reflectionMergePartial<SupportedResolutions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupportedResolutions): SupportedResolutions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.Resolution resolutions */ 1:
                    message.resolutions.push(Resolution.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupportedResolutions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.Resolution resolutions = 1; */
        for (let i = 0; i < message.resolutions.length; i++)
            Resolution.internalBinaryWrite(message.resolutions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SupportedResolutions
 */
export const SupportedResolutions = new SupportedResolutions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchDisplay$Type extends MessageType<SwitchDisplay> {
    constructor() {
        super("hbb.SwitchDisplay", [
            { no: 1, name: "display", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 3, name: "y", kind: "scalar", T: 17 /*ScalarType.SINT32*/ },
            { no: 4, name: "width", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "height", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "cursor_embedded", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "resolutions", kind: "message", T: () => SupportedResolutions },
            { no: 8, name: "original_resolution", kind: "message", T: () => Resolution },
            { no: 9, name: "scale", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SwitchDisplay>): SwitchDisplay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.display = 0;
        message.x = 0;
        message.y = 0;
        message.width = 0;
        message.height = 0;
        message.cursorEmbedded = false;
        message.scale = 0;
        if (value !== undefined)
            reflectionMergePartial<SwitchDisplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchDisplay): SwitchDisplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 display */ 1:
                    message.display = reader.int32();
                    break;
                case /* sint32 x */ 2:
                    message.x = reader.sint32();
                    break;
                case /* sint32 y */ 3:
                    message.y = reader.sint32();
                    break;
                case /* int32 width */ 4:
                    message.width = reader.int32();
                    break;
                case /* int32 height */ 5:
                    message.height = reader.int32();
                    break;
                case /* bool cursor_embedded */ 6:
                    message.cursorEmbedded = reader.bool();
                    break;
                case /* hbb.SupportedResolutions resolutions */ 7:
                    message.resolutions = SupportedResolutions.internalBinaryRead(reader, reader.uint32(), options, message.resolutions);
                    break;
                case /* hbb.Resolution original_resolution */ 8:
                    message.originalResolution = Resolution.internalBinaryRead(reader, reader.uint32(), options, message.originalResolution);
                    break;
                case /* double scale */ 9:
                    message.scale = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchDisplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 display = 1; */
        if (message.display !== 0)
            writer.tag(1, WireType.Varint).int32(message.display);
        /* sint32 x = 2; */
        if (message.x !== 0)
            writer.tag(2, WireType.Varint).sint32(message.x);
        /* sint32 y = 3; */
        if (message.y !== 0)
            writer.tag(3, WireType.Varint).sint32(message.y);
        /* int32 width = 4; */
        if (message.width !== 0)
            writer.tag(4, WireType.Varint).int32(message.width);
        /* int32 height = 5; */
        if (message.height !== 0)
            writer.tag(5, WireType.Varint).int32(message.height);
        /* bool cursor_embedded = 6; */
        if (message.cursorEmbedded !== false)
            writer.tag(6, WireType.Varint).bool(message.cursorEmbedded);
        /* hbb.SupportedResolutions resolutions = 7; */
        if (message.resolutions)
            SupportedResolutions.internalBinaryWrite(message.resolutions, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Resolution original_resolution = 8; */
        if (message.originalResolution)
            Resolution.internalBinaryWrite(message.originalResolution, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* double scale = 9; */
        if (message.scale !== 0)
            writer.tag(9, WireType.Bit64).double(message.scale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SwitchDisplay
 */
export const SwitchDisplay = new SwitchDisplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CaptureDisplays$Type extends MessageType<CaptureDisplays> {
    constructor() {
        super("hbb.CaptureDisplays", [
            { no: 1, name: "add", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sub", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "set", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CaptureDisplays>): CaptureDisplays {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.add = [];
        message.sub = [];
        message.set = [];
        if (value !== undefined)
            reflectionMergePartial<CaptureDisplays>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CaptureDisplays): CaptureDisplays {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 add */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.add.push(reader.int32());
                    else
                        message.add.push(reader.int32());
                    break;
                case /* repeated int32 sub */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.sub.push(reader.int32());
                    else
                        message.sub.push(reader.int32());
                    break;
                case /* repeated int32 set */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.set.push(reader.int32());
                    else
                        message.set.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CaptureDisplays, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 add = 1; */
        if (message.add.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.add.length; i++)
                writer.int32(message.add[i]);
            writer.join();
        }
        /* repeated int32 sub = 2; */
        if (message.sub.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.sub.length; i++)
                writer.int32(message.sub[i]);
            writer.join();
        }
        /* repeated int32 set = 3; */
        if (message.set.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.set.length; i++)
                writer.int32(message.set[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CaptureDisplays
 */
export const CaptureDisplays = new CaptureDisplays$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleVirtualDisplay$Type extends MessageType<ToggleVirtualDisplay> {
    constructor() {
        super("hbb.ToggleVirtualDisplay", [
            { no: 1, name: "display", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "on", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ToggleVirtualDisplay>): ToggleVirtualDisplay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.display = 0;
        message.on = false;
        if (value !== undefined)
            reflectionMergePartial<ToggleVirtualDisplay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleVirtualDisplay): ToggleVirtualDisplay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 display */ 1:
                    message.display = reader.int32();
                    break;
                case /* bool on */ 2:
                    message.on = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleVirtualDisplay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 display = 1; */
        if (message.display !== 0)
            writer.tag(1, WireType.Varint).int32(message.display);
        /* bool on = 2; */
        if (message.on !== false)
            writer.tag(2, WireType.Varint).bool(message.on);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ToggleVirtualDisplay
 */
export const ToggleVirtualDisplay = new ToggleVirtualDisplay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TogglePrivacyMode$Type extends MessageType<TogglePrivacyMode> {
    constructor() {
        super("hbb.TogglePrivacyMode", [
            { no: 1, name: "impl_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "on", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TogglePrivacyMode>): TogglePrivacyMode {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.implKey = "";
        message.on = false;
        if (value !== undefined)
            reflectionMergePartial<TogglePrivacyMode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TogglePrivacyMode): TogglePrivacyMode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string impl_key */ 1:
                    message.implKey = reader.string();
                    break;
                case /* bool on */ 2:
                    message.on = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TogglePrivacyMode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string impl_key = 1; */
        if (message.implKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.implKey);
        /* bool on = 2; */
        if (message.on !== false)
            writer.tag(2, WireType.Varint).bool(message.on);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TogglePrivacyMode
 */
export const TogglePrivacyMode = new TogglePrivacyMode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PermissionInfo$Type extends MessageType<PermissionInfo> {
    constructor() {
        super("hbb.PermissionInfo", [
            { no: 1, name: "permission", kind: "enum", T: () => ["hbb.PermissionInfo.Permission", PermissionInfo_Permission] },
            { no: 2, name: "enabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<PermissionInfo>): PermissionInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.permission = 0;
        message.enabled = false;
        if (value !== undefined)
            reflectionMergePartial<PermissionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PermissionInfo): PermissionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.PermissionInfo.Permission permission */ 1:
                    message.permission = reader.int32();
                    break;
                case /* bool enabled */ 2:
                    message.enabled = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PermissionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.PermissionInfo.Permission permission = 1; */
        if (message.permission !== 0)
            writer.tag(1, WireType.Varint).int32(message.permission);
        /* bool enabled = 2; */
        if (message.enabled !== false)
            writer.tag(2, WireType.Varint).bool(message.enabled);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PermissionInfo
 */
export const PermissionInfo = new PermissionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SupportedDecoding$Type extends MessageType<SupportedDecoding> {
    constructor() {
        super("hbb.SupportedDecoding", [
            { no: 1, name: "ability_vp9", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "ability_h264", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "ability_h265", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "prefer", kind: "enum", T: () => ["hbb.SupportedDecoding.PreferCodec", SupportedDecoding_PreferCodec] },
            { no: 5, name: "ability_vp8", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "ability_av1", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "i444", kind: "message", T: () => CodecAbility },
            { no: 8, name: "prefer_chroma", kind: "enum", T: () => ["hbb.Chroma", Chroma] }
        ]);
    }
    create(value?: PartialMessage<SupportedDecoding>): SupportedDecoding {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.abilityVp9 = 0;
        message.abilityH264 = 0;
        message.abilityH265 = 0;
        message.prefer = 0;
        message.abilityVp8 = 0;
        message.abilityAv1 = 0;
        message.preferChroma = 0;
        if (value !== undefined)
            reflectionMergePartial<SupportedDecoding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SupportedDecoding): SupportedDecoding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 ability_vp9 */ 1:
                    message.abilityVp9 = reader.int32();
                    break;
                case /* int32 ability_h264 */ 2:
                    message.abilityH264 = reader.int32();
                    break;
                case /* int32 ability_h265 */ 3:
                    message.abilityH265 = reader.int32();
                    break;
                case /* hbb.SupportedDecoding.PreferCodec prefer */ 4:
                    message.prefer = reader.int32();
                    break;
                case /* int32 ability_vp8 */ 5:
                    message.abilityVp8 = reader.int32();
                    break;
                case /* int32 ability_av1 */ 6:
                    message.abilityAv1 = reader.int32();
                    break;
                case /* hbb.CodecAbility i444 */ 7:
                    message.i444 = CodecAbility.internalBinaryRead(reader, reader.uint32(), options, message.i444);
                    break;
                case /* hbb.Chroma prefer_chroma */ 8:
                    message.preferChroma = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SupportedDecoding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 ability_vp9 = 1; */
        if (message.abilityVp9 !== 0)
            writer.tag(1, WireType.Varint).int32(message.abilityVp9);
        /* int32 ability_h264 = 2; */
        if (message.abilityH264 !== 0)
            writer.tag(2, WireType.Varint).int32(message.abilityH264);
        /* int32 ability_h265 = 3; */
        if (message.abilityH265 !== 0)
            writer.tag(3, WireType.Varint).int32(message.abilityH265);
        /* hbb.SupportedDecoding.PreferCodec prefer = 4; */
        if (message.prefer !== 0)
            writer.tag(4, WireType.Varint).int32(message.prefer);
        /* int32 ability_vp8 = 5; */
        if (message.abilityVp8 !== 0)
            writer.tag(5, WireType.Varint).int32(message.abilityVp8);
        /* int32 ability_av1 = 6; */
        if (message.abilityAv1 !== 0)
            writer.tag(6, WireType.Varint).int32(message.abilityAv1);
        /* hbb.CodecAbility i444 = 7; */
        if (message.i444)
            CodecAbility.internalBinaryWrite(message.i444, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Chroma prefer_chroma = 8; */
        if (message.preferChroma !== 0)
            writer.tag(8, WireType.Varint).int32(message.preferChroma);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SupportedDecoding
 */
export const SupportedDecoding = new SupportedDecoding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OptionMessage$Type extends MessageType<OptionMessage> {
    constructor() {
        super("hbb.OptionMessage", [
            { no: 1, name: "image_quality", kind: "enum", T: () => ["hbb.ImageQuality", ImageQuality] },
            { no: 2, name: "lock_after_session_end", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 3, name: "show_remote_cursor", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 4, name: "privacy_mode", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 5, name: "block_input", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 6, name: "custom_image_quality", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "disable_audio", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 8, name: "disable_clipboard", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 9, name: "enable_file_transfer", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 10, name: "supported_decoding", kind: "message", T: () => SupportedDecoding },
            { no: 11, name: "custom_fps", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "disable_keyboard", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 15, name: "follow_remote_cursor", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 16, name: "follow_remote_window", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 17, name: "disable_camera", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 18, name: "terminal_persistent", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] },
            { no: 19, name: "show_my_cursor", kind: "enum", T: () => ["hbb.OptionMessage.BoolOption", OptionMessage_BoolOption] }
        ]);
    }
    create(value?: PartialMessage<OptionMessage>): OptionMessage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imageQuality = 0;
        message.lockAfterSessionEnd = 0;
        message.showRemoteCursor = 0;
        message.privacyMode = 0;
        message.blockInput = 0;
        message.customImageQuality = 0;
        message.disableAudio = 0;
        message.disableClipboard = 0;
        message.enableFileTransfer = 0;
        message.customFps = 0;
        message.disableKeyboard = 0;
        message.followRemoteCursor = 0;
        message.followRemoteWindow = 0;
        message.disableCamera = 0;
        message.terminalPersistent = 0;
        message.showMyCursor = 0;
        if (value !== undefined)
            reflectionMergePartial<OptionMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OptionMessage): OptionMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.ImageQuality image_quality */ 1:
                    message.imageQuality = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption lock_after_session_end */ 2:
                    message.lockAfterSessionEnd = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption show_remote_cursor */ 3:
                    message.showRemoteCursor = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption privacy_mode */ 4:
                    message.privacyMode = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption block_input */ 5:
                    message.blockInput = reader.int32();
                    break;
                case /* int32 custom_image_quality */ 6:
                    message.customImageQuality = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption disable_audio */ 7:
                    message.disableAudio = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption disable_clipboard */ 8:
                    message.disableClipboard = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption enable_file_transfer */ 9:
                    message.enableFileTransfer = reader.int32();
                    break;
                case /* hbb.SupportedDecoding supported_decoding */ 10:
                    message.supportedDecoding = SupportedDecoding.internalBinaryRead(reader, reader.uint32(), options, message.supportedDecoding);
                    break;
                case /* int32 custom_fps */ 11:
                    message.customFps = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption disable_keyboard */ 12:
                    message.disableKeyboard = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption follow_remote_cursor */ 15:
                    message.followRemoteCursor = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption follow_remote_window */ 16:
                    message.followRemoteWindow = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption disable_camera */ 17:
                    message.disableCamera = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption terminal_persistent */ 18:
                    message.terminalPersistent = reader.int32();
                    break;
                case /* hbb.OptionMessage.BoolOption show_my_cursor */ 19:
                    message.showMyCursor = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OptionMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.ImageQuality image_quality = 1; */
        if (message.imageQuality !== 0)
            writer.tag(1, WireType.Varint).int32(message.imageQuality);
        /* hbb.OptionMessage.BoolOption lock_after_session_end = 2; */
        if (message.lockAfterSessionEnd !== 0)
            writer.tag(2, WireType.Varint).int32(message.lockAfterSessionEnd);
        /* hbb.OptionMessage.BoolOption show_remote_cursor = 3; */
        if (message.showRemoteCursor !== 0)
            writer.tag(3, WireType.Varint).int32(message.showRemoteCursor);
        /* hbb.OptionMessage.BoolOption privacy_mode = 4; */
        if (message.privacyMode !== 0)
            writer.tag(4, WireType.Varint).int32(message.privacyMode);
        /* hbb.OptionMessage.BoolOption block_input = 5; */
        if (message.blockInput !== 0)
            writer.tag(5, WireType.Varint).int32(message.blockInput);
        /* int32 custom_image_quality = 6; */
        if (message.customImageQuality !== 0)
            writer.tag(6, WireType.Varint).int32(message.customImageQuality);
        /* hbb.OptionMessage.BoolOption disable_audio = 7; */
        if (message.disableAudio !== 0)
            writer.tag(7, WireType.Varint).int32(message.disableAudio);
        /* hbb.OptionMessage.BoolOption disable_clipboard = 8; */
        if (message.disableClipboard !== 0)
            writer.tag(8, WireType.Varint).int32(message.disableClipboard);
        /* hbb.OptionMessage.BoolOption enable_file_transfer = 9; */
        if (message.enableFileTransfer !== 0)
            writer.tag(9, WireType.Varint).int32(message.enableFileTransfer);
        /* hbb.SupportedDecoding supported_decoding = 10; */
        if (message.supportedDecoding)
            SupportedDecoding.internalBinaryWrite(message.supportedDecoding, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* int32 custom_fps = 11; */
        if (message.customFps !== 0)
            writer.tag(11, WireType.Varint).int32(message.customFps);
        /* hbb.OptionMessage.BoolOption disable_keyboard = 12; */
        if (message.disableKeyboard !== 0)
            writer.tag(12, WireType.Varint).int32(message.disableKeyboard);
        /* hbb.OptionMessage.BoolOption follow_remote_cursor = 15; */
        if (message.followRemoteCursor !== 0)
            writer.tag(15, WireType.Varint).int32(message.followRemoteCursor);
        /* hbb.OptionMessage.BoolOption follow_remote_window = 16; */
        if (message.followRemoteWindow !== 0)
            writer.tag(16, WireType.Varint).int32(message.followRemoteWindow);
        /* hbb.OptionMessage.BoolOption disable_camera = 17; */
        if (message.disableCamera !== 0)
            writer.tag(17, WireType.Varint).int32(message.disableCamera);
        /* hbb.OptionMessage.BoolOption terminal_persistent = 18; */
        if (message.terminalPersistent !== 0)
            writer.tag(18, WireType.Varint).int32(message.terminalPersistent);
        /* hbb.OptionMessage.BoolOption show_my_cursor = 19; */
        if (message.showMyCursor !== 0)
            writer.tag(19, WireType.Varint).int32(message.showMyCursor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.OptionMessage
 */
export const OptionMessage = new OptionMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestDelay$Type extends MessageType<TestDelay> {
    constructor() {
        super("hbb.TestDelay", [
            { no: 1, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "from_client", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "last_delay", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "target_bitrate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestDelay>): TestDelay {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.time = 0n;
        message.fromClient = false;
        message.lastDelay = 0;
        message.targetBitrate = 0;
        if (value !== undefined)
            reflectionMergePartial<TestDelay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestDelay): TestDelay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 time */ 1:
                    message.time = reader.int64().toBigInt();
                    break;
                case /* bool from_client */ 2:
                    message.fromClient = reader.bool();
                    break;
                case /* uint32 last_delay */ 3:
                    message.lastDelay = reader.uint32();
                    break;
                case /* uint32 target_bitrate */ 4:
                    message.targetBitrate = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestDelay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 time = 1; */
        if (message.time !== 0n)
            writer.tag(1, WireType.Varint).int64(message.time);
        /* bool from_client = 2; */
        if (message.fromClient !== false)
            writer.tag(2, WireType.Varint).bool(message.fromClient);
        /* uint32 last_delay = 3; */
        if (message.lastDelay !== 0)
            writer.tag(3, WireType.Varint).uint32(message.lastDelay);
        /* uint32 target_bitrate = 4; */
        if (message.targetBitrate !== 0)
            writer.tag(4, WireType.Varint).uint32(message.targetBitrate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TestDelay
 */
export const TestDelay = new TestDelay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PublicKey$Type extends MessageType<PublicKey> {
    constructor() {
        super("hbb.PublicKey", [
            { no: 1, name: "asymmetric_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "symmetric_value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PublicKey>): PublicKey {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.asymmetricValue = new Uint8Array(0);
        message.symmetricValue = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PublicKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PublicKey): PublicKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes asymmetric_value */ 1:
                    message.asymmetricValue = reader.bytes();
                    break;
                case /* bytes symmetric_value */ 2:
                    message.symmetricValue = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PublicKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes asymmetric_value = 1; */
        if (message.asymmetricValue.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.asymmetricValue);
        /* bytes symmetric_value = 2; */
        if (message.symmetricValue.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.symmetricValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PublicKey
 */
export const PublicKey = new PublicKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignedId$Type extends MessageType<SignedId> {
    constructor() {
        super("hbb.SignedId", [
            { no: 1, name: "id", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SignedId>): SignedId {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SignedId>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SignedId): SignedId {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes id */ 1:
                    message.id = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SignedId, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes id = 1; */
        if (message.id.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SignedId
 */
export const SignedId = new SignedId$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioFormat$Type extends MessageType<AudioFormat> {
    constructor() {
        super("hbb.AudioFormat", [
            { no: 1, name: "sample_rate", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "channels", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AudioFormat>): AudioFormat {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sampleRate = 0;
        message.channels = 0;
        if (value !== undefined)
            reflectionMergePartial<AudioFormat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioFormat): AudioFormat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 sample_rate */ 1:
                    message.sampleRate = reader.uint32();
                    break;
                case /* uint32 channels */ 2:
                    message.channels = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioFormat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 sample_rate = 1; */
        if (message.sampleRate !== 0)
            writer.tag(1, WireType.Varint).uint32(message.sampleRate);
        /* uint32 channels = 2; */
        if (message.channels !== 0)
            writer.tag(2, WireType.Varint).uint32(message.channels);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.AudioFormat
 */
export const AudioFormat = new AudioFormat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AudioFrame$Type extends MessageType<AudioFrame> {
    constructor() {
        super("hbb.AudioFrame", [
            { no: 1, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<AudioFrame>): AudioFrame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<AudioFrame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AudioFrame): AudioFrame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AudioFrame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes data = 1; */
        if (message.data.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.AudioFrame
 */
export const AudioFrame = new AudioFrame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageBox$Type extends MessageType<MessageBox> {
    constructor() {
        super("hbb.MessageBox", [
            { no: 1, name: "msgtype", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "title", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "link", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageBox>): MessageBox {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.msgtype = "";
        message.title = "";
        message.text = "";
        message.link = "";
        if (value !== undefined)
            reflectionMergePartial<MessageBox>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageBox): MessageBox {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msgtype */ 1:
                    message.msgtype = reader.string();
                    break;
                case /* string title */ 2:
                    message.title = reader.string();
                    break;
                case /* string text */ 3:
                    message.text = reader.string();
                    break;
                case /* string link */ 4:
                    message.link = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageBox, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msgtype = 1; */
        if (message.msgtype !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msgtype);
        /* string title = 2; */
        if (message.title !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.title);
        /* string text = 3; */
        if (message.text !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.text);
        /* string link = 4; */
        if (message.link !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.link);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.MessageBox
 */
export const MessageBox = new MessageBox$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BackNotification$Type extends MessageType<BackNotification> {
    constructor() {
        super("hbb.BackNotification", [
            { no: 1, name: "privacy_mode_state", kind: "enum", oneof: "union", T: () => ["hbb.BackNotification.PrivacyModeState", BackNotification_PrivacyModeState] },
            { no: 2, name: "block_input_state", kind: "enum", oneof: "union", T: () => ["hbb.BackNotification.BlockInputState", BackNotification_BlockInputState] },
            { no: 3, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "impl_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BackNotification>): BackNotification {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        message.details = "";
        message.implKey = "";
        if (value !== undefined)
            reflectionMergePartial<BackNotification>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BackNotification): BackNotification {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.BackNotification.PrivacyModeState privacy_mode_state */ 1:
                    message.union = {
                        oneofKind: "privacyModeState",
                        privacyModeState: reader.int32()
                    };
                    break;
                case /* hbb.BackNotification.BlockInputState block_input_state */ 2:
                    message.union = {
                        oneofKind: "blockInputState",
                        blockInputState: reader.int32()
                    };
                    break;
                case /* string details */ 3:
                    message.details = reader.string();
                    break;
                case /* string impl_key */ 4:
                    message.implKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BackNotification, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.BackNotification.PrivacyModeState privacy_mode_state = 1; */
        if (message.union.oneofKind === "privacyModeState")
            writer.tag(1, WireType.Varint).int32(message.union.privacyModeState);
        /* hbb.BackNotification.BlockInputState block_input_state = 2; */
        if (message.union.oneofKind === "blockInputState")
            writer.tag(2, WireType.Varint).int32(message.union.blockInputState);
        /* string details = 3; */
        if (message.details !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.details);
        /* string impl_key = 4; */
        if (message.implKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.implKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.BackNotification
 */
export const BackNotification = new BackNotification$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ElevationRequestWithLogon$Type extends MessageType<ElevationRequestWithLogon> {
    constructor() {
        super("hbb.ElevationRequestWithLogon", [
            { no: 1, name: "username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ElevationRequestWithLogon>): ElevationRequestWithLogon {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.username = "";
        message.password = "";
        if (value !== undefined)
            reflectionMergePartial<ElevationRequestWithLogon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElevationRequestWithLogon): ElevationRequestWithLogon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string username */ 1:
                    message.username = reader.string();
                    break;
                case /* string password */ 2:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ElevationRequestWithLogon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string username = 1; */
        if (message.username !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.username);
        /* string password = 2; */
        if (message.password !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ElevationRequestWithLogon
 */
export const ElevationRequestWithLogon = new ElevationRequestWithLogon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ElevationRequest$Type extends MessageType<ElevationRequest> {
    constructor() {
        super("hbb.ElevationRequest", [
            { no: 1, name: "direct", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "logon", kind: "message", oneof: "union", T: () => ElevationRequestWithLogon }
        ]);
    }
    create(value?: PartialMessage<ElevationRequest>): ElevationRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ElevationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ElevationRequest): ElevationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool direct */ 1:
                    message.union = {
                        oneofKind: "direct",
                        direct: reader.bool()
                    };
                    break;
                case /* hbb.ElevationRequestWithLogon logon */ 2:
                    message.union = {
                        oneofKind: "logon",
                        logon: ElevationRequestWithLogon.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).logon)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ElevationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool direct = 1; */
        if (message.union.oneofKind === "direct")
            writer.tag(1, WireType.Varint).bool(message.union.direct);
        /* hbb.ElevationRequestWithLogon logon = 2; */
        if (message.union.oneofKind === "logon")
            ElevationRequestWithLogon.internalBinaryWrite(message.union.logon, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ElevationRequest
 */
export const ElevationRequest = new ElevationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchSidesRequest$Type extends MessageType<SwitchSidesRequest> {
    constructor() {
        super("hbb.SwitchSidesRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<SwitchSidesRequest>): SwitchSidesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SwitchSidesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchSidesRequest): SwitchSidesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchSidesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SwitchSidesRequest
 */
export const SwitchSidesRequest = new SwitchSidesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchSidesResponse$Type extends MessageType<SwitchSidesResponse> {
    constructor() {
        super("hbb.SwitchSidesResponse", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "lr", kind: "message", T: () => LoginRequest }
        ]);
    }
    create(value?: PartialMessage<SwitchSidesResponse>): SwitchSidesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<SwitchSidesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchSidesResponse): SwitchSidesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* hbb.LoginRequest lr */ 2:
                    message.lr = LoginRequest.internalBinaryRead(reader, reader.uint32(), options, message.lr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchSidesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* hbb.LoginRequest lr = 2; */
        if (message.lr)
            LoginRequest.internalBinaryWrite(message.lr, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SwitchSidesResponse
 */
export const SwitchSidesResponse = new SwitchSidesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwitchBack$Type extends MessageType<SwitchBack> {
    constructor() {
        super("hbb.SwitchBack", []);
    }
    create(value?: PartialMessage<SwitchBack>): SwitchBack {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<SwitchBack>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwitchBack): SwitchBack {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwitchBack, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.SwitchBack
 */
export const SwitchBack = new SwitchBack$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginRequest$Type extends MessageType<PluginRequest> {
    constructor() {
        super("hbb.PluginRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "content", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<PluginRequest>): PluginRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.content = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<PluginRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginRequest): PluginRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* bytes content */ 2:
                    message.content = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* bytes content = 2; */
        if (message.content.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.content);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PluginRequest
 */
export const PluginRequest = new PluginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PluginFailure$Type extends MessageType<PluginFailure> {
    constructor() {
        super("hbb.PluginFailure", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PluginFailure>): PluginFailure {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.name = "";
        message.msg = "";
        if (value !== undefined)
            reflectionMergePartial<PluginFailure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PluginFailure): PluginFailure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string msg */ 3:
                    message.msg = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PluginFailure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string msg = 3; */
        if (message.msg !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.msg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.PluginFailure
 */
export const PluginFailure = new PluginFailure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WindowsSessions$Type extends MessageType<WindowsSessions> {
    constructor() {
        super("hbb.WindowsSessions", [
            { no: 1, name: "sessions", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WindowsSession },
            { no: 2, name: "current_sid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<WindowsSessions>): WindowsSessions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sessions = [];
        message.currentSid = 0;
        if (value !== undefined)
            reflectionMergePartial<WindowsSessions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WindowsSessions): WindowsSessions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hbb.WindowsSession sessions */ 1:
                    message.sessions.push(WindowsSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 current_sid */ 2:
                    message.currentSid = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WindowsSessions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hbb.WindowsSession sessions = 1; */
        for (let i = 0; i < message.sessions.length; i++)
            WindowsSession.internalBinaryWrite(message.sessions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 current_sid = 2; */
        if (message.currentSid !== 0)
            writer.tag(2, WireType.Varint).uint32(message.currentSid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.WindowsSessions
 */
export const WindowsSessions = new WindowsSessions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageQuery$Type extends MessageType<MessageQuery> {
    constructor() {
        super("hbb.MessageQuery", [
            { no: 1, name: "switch_display", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MessageQuery>): MessageQuery {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.switchDisplay = 0;
        if (value !== undefined)
            reflectionMergePartial<MessageQuery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageQuery): MessageQuery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 switch_display */ 1:
                    message.switchDisplay = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageQuery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 switch_display = 1; */
        if (message.switchDisplay !== 0)
            writer.tag(1, WireType.Varint).int32(message.switchDisplay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.MessageQuery
 */
export const MessageQuery = new MessageQuery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Misc$Type extends MessageType<Misc> {
    constructor() {
        super("hbb.Misc", [
            { no: 4, name: "chat_message", kind: "message", oneof: "union", T: () => ChatMessage },
            { no: 5, name: "switch_display", kind: "message", oneof: "union", T: () => SwitchDisplay },
            { no: 6, name: "permission_info", kind: "message", oneof: "union", T: () => PermissionInfo },
            { no: 7, name: "option", kind: "message", oneof: "union", T: () => OptionMessage },
            { no: 8, name: "audio_format", kind: "message", oneof: "union", T: () => AudioFormat },
            { no: 9, name: "close_reason", kind: "scalar", oneof: "union", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "refresh_video", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "video_received", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "back_notification", kind: "message", oneof: "union", T: () => BackNotification },
            { no: 14, name: "restart_remote_device", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "uac", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "foreground_window_elevated", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 17, name: "stop_service", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "elevation_request", kind: "message", oneof: "union", T: () => ElevationRequest },
            { no: 19, name: "elevation_response", kind: "scalar", oneof: "union", T: 9 /*ScalarType.STRING*/ },
            { no: 20, name: "portable_service_running", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "switch_sides_request", kind: "message", oneof: "union", T: () => SwitchSidesRequest },
            { no: 22, name: "switch_back", kind: "message", oneof: "union", T: () => SwitchBack },
            { no: 24, name: "change_resolution", kind: "message", oneof: "union", T: () => Resolution },
            { no: 25, name: "plugin_request", kind: "message", oneof: "union", T: () => PluginRequest },
            { no: 26, name: "plugin_failure", kind: "message", oneof: "union", T: () => PluginFailure },
            { no: 27, name: "full_speed_fps", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 28, name: "auto_adjust_fps", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 29, name: "client_record_status", kind: "scalar", oneof: "union", T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "capture_displays", kind: "message", oneof: "union", T: () => CaptureDisplays },
            { no: 31, name: "refresh_video_display", kind: "scalar", oneof: "union", T: 5 /*ScalarType.INT32*/ },
            { no: 32, name: "toggle_virtual_display", kind: "message", oneof: "union", T: () => ToggleVirtualDisplay },
            { no: 33, name: "toggle_privacy_mode", kind: "message", oneof: "union", T: () => TogglePrivacyMode },
            { no: 34, name: "supported_encoding", kind: "message", oneof: "union", T: () => SupportedEncoding },
            { no: 35, name: "selected_sid", kind: "scalar", oneof: "union", T: 13 /*ScalarType.UINT32*/ },
            { no: 36, name: "change_display_resolution", kind: "message", oneof: "union", T: () => DisplayResolution },
            { no: 37, name: "message_query", kind: "message", oneof: "union", T: () => MessageQuery },
            { no: 38, name: "follow_current_display", kind: "scalar", oneof: "union", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Misc>): Misc {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Misc>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Misc): Misc {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.ChatMessage chat_message */ 4:
                    message.union = {
                        oneofKind: "chatMessage",
                        chatMessage: ChatMessage.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).chatMessage)
                    };
                    break;
                case /* hbb.SwitchDisplay switch_display */ 5:
                    message.union = {
                        oneofKind: "switchDisplay",
                        switchDisplay: SwitchDisplay.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).switchDisplay)
                    };
                    break;
                case /* hbb.PermissionInfo permission_info */ 6:
                    message.union = {
                        oneofKind: "permissionInfo",
                        permissionInfo: PermissionInfo.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).permissionInfo)
                    };
                    break;
                case /* hbb.OptionMessage option */ 7:
                    message.union = {
                        oneofKind: "option",
                        option: OptionMessage.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).option)
                    };
                    break;
                case /* hbb.AudioFormat audio_format */ 8:
                    message.union = {
                        oneofKind: "audioFormat",
                        audioFormat: AudioFormat.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).audioFormat)
                    };
                    break;
                case /* string close_reason */ 9:
                    message.union = {
                        oneofKind: "closeReason",
                        closeReason: reader.string()
                    };
                    break;
                case /* bool refresh_video */ 10:
                    message.union = {
                        oneofKind: "refreshVideo",
                        refreshVideo: reader.bool()
                    };
                    break;
                case /* bool video_received */ 12:
                    message.union = {
                        oneofKind: "videoReceived",
                        videoReceived: reader.bool()
                    };
                    break;
                case /* hbb.BackNotification back_notification */ 13:
                    message.union = {
                        oneofKind: "backNotification",
                        backNotification: BackNotification.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).backNotification)
                    };
                    break;
                case /* bool restart_remote_device */ 14:
                    message.union = {
                        oneofKind: "restartRemoteDevice",
                        restartRemoteDevice: reader.bool()
                    };
                    break;
                case /* bool uac */ 15:
                    message.union = {
                        oneofKind: "uac",
                        uac: reader.bool()
                    };
                    break;
                case /* bool foreground_window_elevated */ 16:
                    message.union = {
                        oneofKind: "foregroundWindowElevated",
                        foregroundWindowElevated: reader.bool()
                    };
                    break;
                case /* bool stop_service */ 17:
                    message.union = {
                        oneofKind: "stopService",
                        stopService: reader.bool()
                    };
                    break;
                case /* hbb.ElevationRequest elevation_request */ 18:
                    message.union = {
                        oneofKind: "elevationRequest",
                        elevationRequest: ElevationRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).elevationRequest)
                    };
                    break;
                case /* string elevation_response */ 19:
                    message.union = {
                        oneofKind: "elevationResponse",
                        elevationResponse: reader.string()
                    };
                    break;
                case /* bool portable_service_running */ 20:
                    message.union = {
                        oneofKind: "portableServiceRunning",
                        portableServiceRunning: reader.bool()
                    };
                    break;
                case /* hbb.SwitchSidesRequest switch_sides_request */ 21:
                    message.union = {
                        oneofKind: "switchSidesRequest",
                        switchSidesRequest: SwitchSidesRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).switchSidesRequest)
                    };
                    break;
                case /* hbb.SwitchBack switch_back */ 22:
                    message.union = {
                        oneofKind: "switchBack",
                        switchBack: SwitchBack.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).switchBack)
                    };
                    break;
                case /* hbb.Resolution change_resolution */ 24:
                    message.union = {
                        oneofKind: "changeResolution",
                        changeResolution: Resolution.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).changeResolution)
                    };
                    break;
                case /* hbb.PluginRequest plugin_request */ 25:
                    message.union = {
                        oneofKind: "pluginRequest",
                        pluginRequest: PluginRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).pluginRequest)
                    };
                    break;
                case /* hbb.PluginFailure plugin_failure */ 26:
                    message.union = {
                        oneofKind: "pluginFailure",
                        pluginFailure: PluginFailure.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).pluginFailure)
                    };
                    break;
                case /* uint32 full_speed_fps */ 27:
                    message.union = {
                        oneofKind: "fullSpeedFps",
                        fullSpeedFps: reader.uint32()
                    };
                    break;
                case /* uint32 auto_adjust_fps */ 28:
                    message.union = {
                        oneofKind: "autoAdjustFps",
                        autoAdjustFps: reader.uint32()
                    };
                    break;
                case /* bool client_record_status */ 29:
                    message.union = {
                        oneofKind: "clientRecordStatus",
                        clientRecordStatus: reader.bool()
                    };
                    break;
                case /* hbb.CaptureDisplays capture_displays */ 30:
                    message.union = {
                        oneofKind: "captureDisplays",
                        captureDisplays: CaptureDisplays.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).captureDisplays)
                    };
                    break;
                case /* int32 refresh_video_display */ 31:
                    message.union = {
                        oneofKind: "refreshVideoDisplay",
                        refreshVideoDisplay: reader.int32()
                    };
                    break;
                case /* hbb.ToggleVirtualDisplay toggle_virtual_display */ 32:
                    message.union = {
                        oneofKind: "toggleVirtualDisplay",
                        toggleVirtualDisplay: ToggleVirtualDisplay.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).toggleVirtualDisplay)
                    };
                    break;
                case /* hbb.TogglePrivacyMode toggle_privacy_mode */ 33:
                    message.union = {
                        oneofKind: "togglePrivacyMode",
                        togglePrivacyMode: TogglePrivacyMode.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).togglePrivacyMode)
                    };
                    break;
                case /* hbb.SupportedEncoding supported_encoding */ 34:
                    message.union = {
                        oneofKind: "supportedEncoding",
                        supportedEncoding: SupportedEncoding.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).supportedEncoding)
                    };
                    break;
                case /* uint32 selected_sid */ 35:
                    message.union = {
                        oneofKind: "selectedSid",
                        selectedSid: reader.uint32()
                    };
                    break;
                case /* hbb.DisplayResolution change_display_resolution */ 36:
                    message.union = {
                        oneofKind: "changeDisplayResolution",
                        changeDisplayResolution: DisplayResolution.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).changeDisplayResolution)
                    };
                    break;
                case /* hbb.MessageQuery message_query */ 37:
                    message.union = {
                        oneofKind: "messageQuery",
                        messageQuery: MessageQuery.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).messageQuery)
                    };
                    break;
                case /* int32 follow_current_display */ 38:
                    message.union = {
                        oneofKind: "followCurrentDisplay",
                        followCurrentDisplay: reader.int32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Misc, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.ChatMessage chat_message = 4; */
        if (message.union.oneofKind === "chatMessage")
            ChatMessage.internalBinaryWrite(message.union.chatMessage, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SwitchDisplay switch_display = 5; */
        if (message.union.oneofKind === "switchDisplay")
            SwitchDisplay.internalBinaryWrite(message.union.switchDisplay, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PermissionInfo permission_info = 6; */
        if (message.union.oneofKind === "permissionInfo")
            PermissionInfo.internalBinaryWrite(message.union.permissionInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.OptionMessage option = 7; */
        if (message.union.oneofKind === "option")
            OptionMessage.internalBinaryWrite(message.union.option, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.AudioFormat audio_format = 8; */
        if (message.union.oneofKind === "audioFormat")
            AudioFormat.internalBinaryWrite(message.union.audioFormat, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* string close_reason = 9; */
        if (message.union.oneofKind === "closeReason")
            writer.tag(9, WireType.LengthDelimited).string(message.union.closeReason);
        /* bool refresh_video = 10; */
        if (message.union.oneofKind === "refreshVideo")
            writer.tag(10, WireType.Varint).bool(message.union.refreshVideo);
        /* bool video_received = 12; */
        if (message.union.oneofKind === "videoReceived")
            writer.tag(12, WireType.Varint).bool(message.union.videoReceived);
        /* hbb.BackNotification back_notification = 13; */
        if (message.union.oneofKind === "backNotification")
            BackNotification.internalBinaryWrite(message.union.backNotification, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* bool restart_remote_device = 14; */
        if (message.union.oneofKind === "restartRemoteDevice")
            writer.tag(14, WireType.Varint).bool(message.union.restartRemoteDevice);
        /* bool uac = 15; */
        if (message.union.oneofKind === "uac")
            writer.tag(15, WireType.Varint).bool(message.union.uac);
        /* bool foreground_window_elevated = 16; */
        if (message.union.oneofKind === "foregroundWindowElevated")
            writer.tag(16, WireType.Varint).bool(message.union.foregroundWindowElevated);
        /* bool stop_service = 17; */
        if (message.union.oneofKind === "stopService")
            writer.tag(17, WireType.Varint).bool(message.union.stopService);
        /* hbb.ElevationRequest elevation_request = 18; */
        if (message.union.oneofKind === "elevationRequest")
            ElevationRequest.internalBinaryWrite(message.union.elevationRequest, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* string elevation_response = 19; */
        if (message.union.oneofKind === "elevationResponse")
            writer.tag(19, WireType.LengthDelimited).string(message.union.elevationResponse);
        /* bool portable_service_running = 20; */
        if (message.union.oneofKind === "portableServiceRunning")
            writer.tag(20, WireType.Varint).bool(message.union.portableServiceRunning);
        /* hbb.SwitchSidesRequest switch_sides_request = 21; */
        if (message.union.oneofKind === "switchSidesRequest")
            SwitchSidesRequest.internalBinaryWrite(message.union.switchSidesRequest, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SwitchBack switch_back = 22; */
        if (message.union.oneofKind === "switchBack")
            SwitchBack.internalBinaryWrite(message.union.switchBack, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Resolution change_resolution = 24; */
        if (message.union.oneofKind === "changeResolution")
            Resolution.internalBinaryWrite(message.union.changeResolution, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PluginRequest plugin_request = 25; */
        if (message.union.oneofKind === "pluginRequest")
            PluginRequest.internalBinaryWrite(message.union.pluginRequest, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PluginFailure plugin_failure = 26; */
        if (message.union.oneofKind === "pluginFailure")
            PluginFailure.internalBinaryWrite(message.union.pluginFailure, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* uint32 full_speed_fps = 27; */
        if (message.union.oneofKind === "fullSpeedFps")
            writer.tag(27, WireType.Varint).uint32(message.union.fullSpeedFps);
        /* uint32 auto_adjust_fps = 28; */
        if (message.union.oneofKind === "autoAdjustFps")
            writer.tag(28, WireType.Varint).uint32(message.union.autoAdjustFps);
        /* bool client_record_status = 29; */
        if (message.union.oneofKind === "clientRecordStatus")
            writer.tag(29, WireType.Varint).bool(message.union.clientRecordStatus);
        /* hbb.CaptureDisplays capture_displays = 30; */
        if (message.union.oneofKind === "captureDisplays")
            CaptureDisplays.internalBinaryWrite(message.union.captureDisplays, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* int32 refresh_video_display = 31; */
        if (message.union.oneofKind === "refreshVideoDisplay")
            writer.tag(31, WireType.Varint).int32(message.union.refreshVideoDisplay);
        /* hbb.ToggleVirtualDisplay toggle_virtual_display = 32; */
        if (message.union.oneofKind === "toggleVirtualDisplay")
            ToggleVirtualDisplay.internalBinaryWrite(message.union.toggleVirtualDisplay, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TogglePrivacyMode toggle_privacy_mode = 33; */
        if (message.union.oneofKind === "togglePrivacyMode")
            TogglePrivacyMode.internalBinaryWrite(message.union.togglePrivacyMode, writer.tag(33, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SupportedEncoding supported_encoding = 34; */
        if (message.union.oneofKind === "supportedEncoding")
            SupportedEncoding.internalBinaryWrite(message.union.supportedEncoding, writer.tag(34, WireType.LengthDelimited).fork(), options).join();
        /* uint32 selected_sid = 35; */
        if (message.union.oneofKind === "selectedSid")
            writer.tag(35, WireType.Varint).uint32(message.union.selectedSid);
        /* hbb.DisplayResolution change_display_resolution = 36; */
        if (message.union.oneofKind === "changeDisplayResolution")
            DisplayResolution.internalBinaryWrite(message.union.changeDisplayResolution, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* hbb.MessageQuery message_query = 37; */
        if (message.union.oneofKind === "messageQuery")
            MessageQuery.internalBinaryWrite(message.union.messageQuery, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* int32 follow_current_display = 38; */
        if (message.union.oneofKind === "followCurrentDisplay")
            writer.tag(38, WireType.Varint).int32(message.union.followCurrentDisplay);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Misc
 */
export const Misc = new Misc$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceCallRequest$Type extends MessageType<VoiceCallRequest> {
    constructor() {
        super("hbb.VoiceCallRequest", [
            { no: 1, name: "req_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "is_connect", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<VoiceCallRequest>): VoiceCallRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reqTimestamp = 0n;
        message.isConnect = false;
        if (value !== undefined)
            reflectionMergePartial<VoiceCallRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceCallRequest): VoiceCallRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 req_timestamp */ 1:
                    message.reqTimestamp = reader.int64().toBigInt();
                    break;
                case /* bool is_connect */ 2:
                    message.isConnect = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceCallRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 req_timestamp = 1; */
        if (message.reqTimestamp !== 0n)
            writer.tag(1, WireType.Varint).int64(message.reqTimestamp);
        /* bool is_connect = 2; */
        if (message.isConnect !== false)
            writer.tag(2, WireType.Varint).bool(message.isConnect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.VoiceCallRequest
 */
export const VoiceCallRequest = new VoiceCallRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class VoiceCallResponse$Type extends MessageType<VoiceCallResponse> {
    constructor() {
        super("hbb.VoiceCallResponse", [
            { no: 1, name: "accepted", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "req_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "ack_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<VoiceCallResponse>): VoiceCallResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.accepted = false;
        message.reqTimestamp = 0n;
        message.ackTimestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<VoiceCallResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: VoiceCallResponse): VoiceCallResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool accepted */ 1:
                    message.accepted = reader.bool();
                    break;
                case /* int64 req_timestamp */ 2:
                    message.reqTimestamp = reader.int64().toBigInt();
                    break;
                case /* int64 ack_timestamp */ 3:
                    message.ackTimestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: VoiceCallResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool accepted = 1; */
        if (message.accepted !== false)
            writer.tag(1, WireType.Varint).bool(message.accepted);
        /* int64 req_timestamp = 2; */
        if (message.reqTimestamp !== 0n)
            writer.tag(2, WireType.Varint).int64(message.reqTimestamp);
        /* int64 ack_timestamp = 3; */
        if (message.ackTimestamp !== 0n)
            writer.tag(3, WireType.Varint).int64(message.ackTimestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.VoiceCallResponse
 */
export const VoiceCallResponse = new VoiceCallResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScreenshotRequest$Type extends MessageType<ScreenshotRequest> {
    constructor() {
        super("hbb.ScreenshotRequest", [
            { no: 1, name: "display", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ScreenshotRequest>): ScreenshotRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.display = 0;
        message.sid = "";
        if (value !== undefined)
            reflectionMergePartial<ScreenshotRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScreenshotRequest): ScreenshotRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 display */ 1:
                    message.display = reader.int32();
                    break;
                case /* string sid */ 2:
                    message.sid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScreenshotRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 display = 1; */
        if (message.display !== 0)
            writer.tag(1, WireType.Varint).int32(message.display);
        /* string sid = 2; */
        if (message.sid !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.sid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ScreenshotRequest
 */
export const ScreenshotRequest = new ScreenshotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScreenshotResponse$Type extends MessageType<ScreenshotResponse> {
    constructor() {
        super("hbb.ScreenshotResponse", [
            { no: 1, name: "sid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ScreenshotResponse>): ScreenshotResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sid = "";
        message.msg = "";
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ScreenshotResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScreenshotResponse): ScreenshotResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string sid */ 1:
                    message.sid = reader.string();
                    break;
                case /* string msg */ 2:
                    message.msg = reader.string();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScreenshotResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string sid = 1; */
        if (message.sid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.sid);
        /* string msg = 2; */
        if (message.msg !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msg);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ScreenshotResponse
 */
export const ScreenshotResponse = new ScreenshotResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenTerminal$Type extends MessageType<OpenTerminal> {
    constructor() {
        super("hbb.OpenTerminal", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cols", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<OpenTerminal>): OpenTerminal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.rows = 0;
        message.cols = 0;
        if (value !== undefined)
            reflectionMergePartial<OpenTerminal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenTerminal): OpenTerminal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* uint32 rows */ 2:
                    message.rows = reader.uint32();
                    break;
                case /* uint32 cols */ 3:
                    message.cols = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenTerminal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* uint32 rows = 2; */
        if (message.rows !== 0)
            writer.tag(2, WireType.Varint).uint32(message.rows);
        /* uint32 cols = 3; */
        if (message.cols !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cols);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.OpenTerminal
 */
export const OpenTerminal = new OpenTerminal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResizeTerminal$Type extends MessageType<ResizeTerminal> {
    constructor() {
        super("hbb.ResizeTerminal", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rows", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "cols", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResizeTerminal>): ResizeTerminal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.rows = 0;
        message.cols = 0;
        if (value !== undefined)
            reflectionMergePartial<ResizeTerminal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResizeTerminal): ResizeTerminal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* uint32 rows */ 2:
                    message.rows = reader.uint32();
                    break;
                case /* uint32 cols */ 3:
                    message.cols = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResizeTerminal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* uint32 rows = 2; */
        if (message.rows !== 0)
            writer.tag(2, WireType.Varint).uint32(message.rows);
        /* uint32 cols = 3; */
        if (message.cols !== 0)
            writer.tag(3, WireType.Varint).uint32(message.cols);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.ResizeTerminal
 */
export const ResizeTerminal = new ResizeTerminal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalData$Type extends MessageType<TerminalData> {
    constructor() {
        super("hbb.TerminalData", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "compressed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalData>): TerminalData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.data = new Uint8Array(0);
        message.compressed = false;
        if (value !== undefined)
            reflectionMergePartial<TerminalData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalData): TerminalData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* bool compressed */ 3:
                    message.compressed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* bool compressed = 3; */
        if (message.compressed !== false)
            writer.tag(3, WireType.Varint).bool(message.compressed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalData
 */
export const TerminalData = new TerminalData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseTerminal$Type extends MessageType<CloseTerminal> {
    constructor() {
        super("hbb.CloseTerminal", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CloseTerminal>): CloseTerminal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        if (value !== undefined)
            reflectionMergePartial<CloseTerminal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseTerminal): CloseTerminal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseTerminal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.CloseTerminal
 */
export const CloseTerminal = new CloseTerminal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalAction$Type extends MessageType<TerminalAction> {
    constructor() {
        super("hbb.TerminalAction", [
            { no: 1, name: "open", kind: "message", oneof: "union", T: () => OpenTerminal },
            { no: 2, name: "data", kind: "message", oneof: "union", T: () => TerminalData },
            { no: 3, name: "resize", kind: "message", oneof: "union", T: () => ResizeTerminal },
            { no: 4, name: "close", kind: "message", oneof: "union", T: () => CloseTerminal }
        ]);
    }
    create(value?: PartialMessage<TerminalAction>): TerminalAction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TerminalAction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalAction): TerminalAction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.OpenTerminal open */ 1:
                    message.union = {
                        oneofKind: "open",
                        open: OpenTerminal.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).open)
                    };
                    break;
                case /* hbb.TerminalData data */ 2:
                    message.union = {
                        oneofKind: "data",
                        data: TerminalData.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).data)
                    };
                    break;
                case /* hbb.ResizeTerminal resize */ 3:
                    message.union = {
                        oneofKind: "resize",
                        resize: ResizeTerminal.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).resize)
                    };
                    break;
                case /* hbb.CloseTerminal close */ 4:
                    message.union = {
                        oneofKind: "close",
                        close: CloseTerminal.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).close)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalAction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.OpenTerminal open = 1; */
        if (message.union.oneofKind === "open")
            OpenTerminal.internalBinaryWrite(message.union.open, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalData data = 2; */
        if (message.union.oneofKind === "data")
            TerminalData.internalBinaryWrite(message.union.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ResizeTerminal resize = 3; */
        if (message.union.oneofKind === "resize")
            ResizeTerminal.internalBinaryWrite(message.union.resize, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CloseTerminal close = 4; */
        if (message.union.oneofKind === "close")
            CloseTerminal.internalBinaryWrite(message.union.close, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalAction
 */
export const TerminalAction = new TerminalAction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalOpened$Type extends MessageType<TerminalOpened> {
    constructor() {
        super("hbb.TerminalOpened", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "pid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "service_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "persistent_sessions", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalOpened>): TerminalOpened {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.success = false;
        message.message = "";
        message.pid = 0;
        message.serviceId = "";
        message.persistentSessions = [];
        if (value !== undefined)
            reflectionMergePartial<TerminalOpened>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalOpened): TerminalOpened {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* uint32 pid */ 4:
                    message.pid = reader.uint32();
                    break;
                case /* string service_id */ 5:
                    message.serviceId = reader.string();
                    break;
                case /* repeated int32 persistent_sessions */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.persistentSessions.push(reader.int32());
                    else
                        message.persistentSessions.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalOpened, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* uint32 pid = 4; */
        if (message.pid !== 0)
            writer.tag(4, WireType.Varint).uint32(message.pid);
        /* string service_id = 5; */
        if (message.serviceId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.serviceId);
        /* repeated int32 persistent_sessions = 6; */
        if (message.persistentSessions.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.persistentSessions.length; i++)
                writer.int32(message.persistentSessions[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalOpened
 */
export const TerminalOpened = new TerminalOpened$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalClosed$Type extends MessageType<TerminalClosed> {
    constructor() {
        super("hbb.TerminalClosed", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "exit_code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalClosed>): TerminalClosed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.exitCode = 0;
        if (value !== undefined)
            reflectionMergePartial<TerminalClosed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalClosed): TerminalClosed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* int32 exit_code */ 2:
                    message.exitCode = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalClosed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* int32 exit_code = 2; */
        if (message.exitCode !== 0)
            writer.tag(2, WireType.Varint).int32(message.exitCode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalClosed
 */
export const TerminalClosed = new TerminalClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalError$Type extends MessageType<TerminalError> {
    constructor() {
        super("hbb.TerminalError", [
            { no: 1, name: "terminal_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TerminalError>): TerminalError {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.terminalId = 0;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<TerminalError>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalError): TerminalError {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 terminal_id */ 1:
                    message.terminalId = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalError, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 terminal_id = 1; */
        if (message.terminalId !== 0)
            writer.tag(1, WireType.Varint).int32(message.terminalId);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalError
 */
export const TerminalError = new TerminalError$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TerminalResponse$Type extends MessageType<TerminalResponse> {
    constructor() {
        super("hbb.TerminalResponse", [
            { no: 1, name: "opened", kind: "message", oneof: "union", T: () => TerminalOpened },
            { no: 2, name: "data", kind: "message", oneof: "union", T: () => TerminalData },
            { no: 3, name: "closed", kind: "message", oneof: "union", T: () => TerminalClosed },
            { no: 4, name: "error", kind: "message", oneof: "union", T: () => TerminalError }
        ]);
    }
    create(value?: PartialMessage<TerminalResponse>): TerminalResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<TerminalResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TerminalResponse): TerminalResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.TerminalOpened opened */ 1:
                    message.union = {
                        oneofKind: "opened",
                        opened: TerminalOpened.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).opened)
                    };
                    break;
                case /* hbb.TerminalData data */ 2:
                    message.union = {
                        oneofKind: "data",
                        data: TerminalData.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).data)
                    };
                    break;
                case /* hbb.TerminalClosed closed */ 3:
                    message.union = {
                        oneofKind: "closed",
                        closed: TerminalClosed.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).closed)
                    };
                    break;
                case /* hbb.TerminalError error */ 4:
                    message.union = {
                        oneofKind: "error",
                        error: TerminalError.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).error)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TerminalResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.TerminalOpened opened = 1; */
        if (message.union.oneofKind === "opened")
            TerminalOpened.internalBinaryWrite(message.union.opened, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalData data = 2; */
        if (message.union.oneofKind === "data")
            TerminalData.internalBinaryWrite(message.union.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalClosed closed = 3; */
        if (message.union.oneofKind === "closed")
            TerminalClosed.internalBinaryWrite(message.union.closed, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalError error = 4; */
        if (message.union.oneofKind === "error")
            TerminalError.internalBinaryWrite(message.union.error, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.TerminalResponse
 */
export const TerminalResponse = new TerminalResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType<Message> {
    constructor() {
        super("hbb.Message", [
            { no: 3, name: "signed_id", kind: "message", oneof: "union", T: () => SignedId },
            { no: 4, name: "public_key", kind: "message", oneof: "union", T: () => PublicKey },
            { no: 5, name: "test_delay", kind: "message", oneof: "union", T: () => TestDelay },
            { no: 6, name: "video_frame", kind: "message", oneof: "union", T: () => VideoFrame },
            { no: 7, name: "login_request", kind: "message", oneof: "union", T: () => LoginRequest },
            { no: 8, name: "login_response", kind: "message", oneof: "union", T: () => LoginResponse },
            { no: 9, name: "hash", kind: "message", oneof: "union", T: () => Hash },
            { no: 10, name: "mouse_event", kind: "message", oneof: "union", T: () => MouseEvent },
            { no: 11, name: "audio_frame", kind: "message", oneof: "union", T: () => AudioFrame },
            { no: 12, name: "cursor_data", kind: "message", oneof: "union", T: () => CursorData },
            { no: 13, name: "cursor_position", kind: "message", oneof: "union", T: () => CursorPosition },
            { no: 14, name: "cursor_id", kind: "scalar", oneof: "union", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 15, name: "key_event", kind: "message", oneof: "union", T: () => KeyEvent },
            { no: 16, name: "clipboard", kind: "message", oneof: "union", T: () => Clipboard },
            { no: 17, name: "file_action", kind: "message", oneof: "union", T: () => FileAction },
            { no: 18, name: "file_response", kind: "message", oneof: "union", T: () => FileResponse },
            { no: 19, name: "misc", kind: "message", oneof: "union", T: () => Misc },
            { no: 20, name: "cliprdr", kind: "message", oneof: "union", T: () => Cliprdr },
            { no: 21, name: "message_box", kind: "message", oneof: "union", T: () => MessageBox },
            { no: 22, name: "switch_sides_response", kind: "message", oneof: "union", T: () => SwitchSidesResponse },
            { no: 23, name: "voice_call_request", kind: "message", oneof: "union", T: () => VoiceCallRequest },
            { no: 24, name: "voice_call_response", kind: "message", oneof: "union", T: () => VoiceCallResponse },
            { no: 25, name: "peer_info", kind: "message", oneof: "union", T: () => PeerInfo },
            { no: 26, name: "pointer_device_event", kind: "message", oneof: "union", T: () => PointerDeviceEvent },
            { no: 27, name: "auth_2fa", kind: "message", jsonName: "auth2fa", oneof: "union", T: () => Auth2FA },
            { no: 28, name: "multi_clipboards", kind: "message", oneof: "union", T: () => MultiClipboards },
            { no: 29, name: "screenshot_request", kind: "message", oneof: "union", T: () => ScreenshotRequest },
            { no: 30, name: "screenshot_response", kind: "message", oneof: "union", T: () => ScreenshotResponse },
            { no: 31, name: "terminal_action", kind: "message", oneof: "union", T: () => TerminalAction },
            { no: 32, name: "terminal_response", kind: "message", oneof: "union", T: () => TerminalResponse }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.union = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hbb.SignedId signed_id */ 3:
                    message.union = {
                        oneofKind: "signedId",
                        signedId: SignedId.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).signedId)
                    };
                    break;
                case /* hbb.PublicKey public_key */ 4:
                    message.union = {
                        oneofKind: "publicKey",
                        publicKey: PublicKey.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).publicKey)
                    };
                    break;
                case /* hbb.TestDelay test_delay */ 5:
                    message.union = {
                        oneofKind: "testDelay",
                        testDelay: TestDelay.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).testDelay)
                    };
                    break;
                case /* hbb.VideoFrame video_frame */ 6:
                    message.union = {
                        oneofKind: "videoFrame",
                        videoFrame: VideoFrame.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).videoFrame)
                    };
                    break;
                case /* hbb.LoginRequest login_request */ 7:
                    message.union = {
                        oneofKind: "loginRequest",
                        loginRequest: LoginRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).loginRequest)
                    };
                    break;
                case /* hbb.LoginResponse login_response */ 8:
                    message.union = {
                        oneofKind: "loginResponse",
                        loginResponse: LoginResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).loginResponse)
                    };
                    break;
                case /* hbb.Hash hash */ 9:
                    message.union = {
                        oneofKind: "hash",
                        hash: Hash.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).hash)
                    };
                    break;
                case /* hbb.MouseEvent mouse_event */ 10:
                    message.union = {
                        oneofKind: "mouseEvent",
                        mouseEvent: MouseEvent.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).mouseEvent)
                    };
                    break;
                case /* hbb.AudioFrame audio_frame */ 11:
                    message.union = {
                        oneofKind: "audioFrame",
                        audioFrame: AudioFrame.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).audioFrame)
                    };
                    break;
                case /* hbb.CursorData cursor_data */ 12:
                    message.union = {
                        oneofKind: "cursorData",
                        cursorData: CursorData.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).cursorData)
                    };
                    break;
                case /* hbb.CursorPosition cursor_position */ 13:
                    message.union = {
                        oneofKind: "cursorPosition",
                        cursorPosition: CursorPosition.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).cursorPosition)
                    };
                    break;
                case /* uint64 cursor_id */ 14:
                    message.union = {
                        oneofKind: "cursorId",
                        cursorId: reader.uint64().toBigInt()
                    };
                    break;
                case /* hbb.KeyEvent key_event */ 15:
                    message.union = {
                        oneofKind: "keyEvent",
                        keyEvent: KeyEvent.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).keyEvent)
                    };
                    break;
                case /* hbb.Clipboard clipboard */ 16:
                    message.union = {
                        oneofKind: "clipboard",
                        clipboard: Clipboard.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).clipboard)
                    };
                    break;
                case /* hbb.FileAction file_action */ 17:
                    message.union = {
                        oneofKind: "fileAction",
                        fileAction: FileAction.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fileAction)
                    };
                    break;
                case /* hbb.FileResponse file_response */ 18:
                    message.union = {
                        oneofKind: "fileResponse",
                        fileResponse: FileResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).fileResponse)
                    };
                    break;
                case /* hbb.Misc misc */ 19:
                    message.union = {
                        oneofKind: "misc",
                        misc: Misc.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).misc)
                    };
                    break;
                case /* hbb.Cliprdr cliprdr */ 20:
                    message.union = {
                        oneofKind: "cliprdr",
                        cliprdr: Cliprdr.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).cliprdr)
                    };
                    break;
                case /* hbb.MessageBox message_box */ 21:
                    message.union = {
                        oneofKind: "messageBox",
                        messageBox: MessageBox.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).messageBox)
                    };
                    break;
                case /* hbb.SwitchSidesResponse switch_sides_response */ 22:
                    message.union = {
                        oneofKind: "switchSidesResponse",
                        switchSidesResponse: SwitchSidesResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).switchSidesResponse)
                    };
                    break;
                case /* hbb.VoiceCallRequest voice_call_request */ 23:
                    message.union = {
                        oneofKind: "voiceCallRequest",
                        voiceCallRequest: VoiceCallRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).voiceCallRequest)
                    };
                    break;
                case /* hbb.VoiceCallResponse voice_call_response */ 24:
                    message.union = {
                        oneofKind: "voiceCallResponse",
                        voiceCallResponse: VoiceCallResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).voiceCallResponse)
                    };
                    break;
                case /* hbb.PeerInfo peer_info */ 25:
                    message.union = {
                        oneofKind: "peerInfo",
                        peerInfo: PeerInfo.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).peerInfo)
                    };
                    break;
                case /* hbb.PointerDeviceEvent pointer_device_event */ 26:
                    message.union = {
                        oneofKind: "pointerDeviceEvent",
                        pointerDeviceEvent: PointerDeviceEvent.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).pointerDeviceEvent)
                    };
                    break;
                case /* hbb.Auth2FA auth_2fa */ 27:
                    message.union = {
                        oneofKind: "auth2Fa",
                        auth2Fa: Auth2FA.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).auth2Fa)
                    };
                    break;
                case /* hbb.MultiClipboards multi_clipboards */ 28:
                    message.union = {
                        oneofKind: "multiClipboards",
                        multiClipboards: MultiClipboards.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).multiClipboards)
                    };
                    break;
                case /* hbb.ScreenshotRequest screenshot_request */ 29:
                    message.union = {
                        oneofKind: "screenshotRequest",
                        screenshotRequest: ScreenshotRequest.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).screenshotRequest)
                    };
                    break;
                case /* hbb.ScreenshotResponse screenshot_response */ 30:
                    message.union = {
                        oneofKind: "screenshotResponse",
                        screenshotResponse: ScreenshotResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).screenshotResponse)
                    };
                    break;
                case /* hbb.TerminalAction terminal_action */ 31:
                    message.union = {
                        oneofKind: "terminalAction",
                        terminalAction: TerminalAction.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).terminalAction)
                    };
                    break;
                case /* hbb.TerminalResponse terminal_response */ 32:
                    message.union = {
                        oneofKind: "terminalResponse",
                        terminalResponse: TerminalResponse.internalBinaryRead(reader, reader.uint32(), options, (message.union as any).terminalResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hbb.SignedId signed_id = 3; */
        if (message.union.oneofKind === "signedId")
            SignedId.internalBinaryWrite(message.union.signedId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PublicKey public_key = 4; */
        if (message.union.oneofKind === "publicKey")
            PublicKey.internalBinaryWrite(message.union.publicKey, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TestDelay test_delay = 5; */
        if (message.union.oneofKind === "testDelay")
            TestDelay.internalBinaryWrite(message.union.testDelay, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hbb.VideoFrame video_frame = 6; */
        if (message.union.oneofKind === "videoFrame")
            VideoFrame.internalBinaryWrite(message.union.videoFrame, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* hbb.LoginRequest login_request = 7; */
        if (message.union.oneofKind === "loginRequest")
            LoginRequest.internalBinaryWrite(message.union.loginRequest, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* hbb.LoginResponse login_response = 8; */
        if (message.union.oneofKind === "loginResponse")
            LoginResponse.internalBinaryWrite(message.union.loginResponse, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Hash hash = 9; */
        if (message.union.oneofKind === "hash")
            Hash.internalBinaryWrite(message.union.hash, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* hbb.MouseEvent mouse_event = 10; */
        if (message.union.oneofKind === "mouseEvent")
            MouseEvent.internalBinaryWrite(message.union.mouseEvent, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* hbb.AudioFrame audio_frame = 11; */
        if (message.union.oneofKind === "audioFrame")
            AudioFrame.internalBinaryWrite(message.union.audioFrame, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CursorData cursor_data = 12; */
        if (message.union.oneofKind === "cursorData")
            CursorData.internalBinaryWrite(message.union.cursorData, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* hbb.CursorPosition cursor_position = 13; */
        if (message.union.oneofKind === "cursorPosition")
            CursorPosition.internalBinaryWrite(message.union.cursorPosition, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* uint64 cursor_id = 14; */
        if (message.union.oneofKind === "cursorId")
            writer.tag(14, WireType.Varint).uint64(message.union.cursorId);
        /* hbb.KeyEvent key_event = 15; */
        if (message.union.oneofKind === "keyEvent")
            KeyEvent.internalBinaryWrite(message.union.keyEvent, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Clipboard clipboard = 16; */
        if (message.union.oneofKind === "clipboard")
            Clipboard.internalBinaryWrite(message.union.clipboard, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileAction file_action = 17; */
        if (message.union.oneofKind === "fileAction")
            FileAction.internalBinaryWrite(message.union.fileAction, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* hbb.FileResponse file_response = 18; */
        if (message.union.oneofKind === "fileResponse")
            FileResponse.internalBinaryWrite(message.union.fileResponse, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Misc misc = 19; */
        if (message.union.oneofKind === "misc")
            Misc.internalBinaryWrite(message.union.misc, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Cliprdr cliprdr = 20; */
        if (message.union.oneofKind === "cliprdr")
            Cliprdr.internalBinaryWrite(message.union.cliprdr, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* hbb.MessageBox message_box = 21; */
        if (message.union.oneofKind === "messageBox")
            MessageBox.internalBinaryWrite(message.union.messageBox, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* hbb.SwitchSidesResponse switch_sides_response = 22; */
        if (message.union.oneofKind === "switchSidesResponse")
            SwitchSidesResponse.internalBinaryWrite(message.union.switchSidesResponse, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* hbb.VoiceCallRequest voice_call_request = 23; */
        if (message.union.oneofKind === "voiceCallRequest")
            VoiceCallRequest.internalBinaryWrite(message.union.voiceCallRequest, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* hbb.VoiceCallResponse voice_call_response = 24; */
        if (message.union.oneofKind === "voiceCallResponse")
            VoiceCallResponse.internalBinaryWrite(message.union.voiceCallResponse, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PeerInfo peer_info = 25; */
        if (message.union.oneofKind === "peerInfo")
            PeerInfo.internalBinaryWrite(message.union.peerInfo, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* hbb.PointerDeviceEvent pointer_device_event = 26; */
        if (message.union.oneofKind === "pointerDeviceEvent")
            PointerDeviceEvent.internalBinaryWrite(message.union.pointerDeviceEvent, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* hbb.Auth2FA auth_2fa = 27; */
        if (message.union.oneofKind === "auth2Fa")
            Auth2FA.internalBinaryWrite(message.union.auth2Fa, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* hbb.MultiClipboards multi_clipboards = 28; */
        if (message.union.oneofKind === "multiClipboards")
            MultiClipboards.internalBinaryWrite(message.union.multiClipboards, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ScreenshotRequest screenshot_request = 29; */
        if (message.union.oneofKind === "screenshotRequest")
            ScreenshotRequest.internalBinaryWrite(message.union.screenshotRequest, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* hbb.ScreenshotResponse screenshot_response = 30; */
        if (message.union.oneofKind === "screenshotResponse")
            ScreenshotResponse.internalBinaryWrite(message.union.screenshotResponse, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalAction terminal_action = 31; */
        if (message.union.oneofKind === "terminalAction")
            TerminalAction.internalBinaryWrite(message.union.terminalAction, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* hbb.TerminalResponse terminal_response = 32; */
        if (message.union.oneofKind === "terminalResponse")
            TerminalResponse.internalBinaryWrite(message.union.terminalResponse, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hbb.Message
 */
export const Message = new Message$Type();
